<?php
/**
 * @file
 * A module to perform custom migration from one version of Drupal to another.
 */

/**
 * Implements hook_menu().
 */
function fin_migrate_menu() {
  $items = array();

  $items['admin/content/fin_migrate'] = array(
    'title' => 'FIN D5-to-D7 migrate',
    'description' => 'Migrate data from D5 production to new D7 - Users, Search data, links between them.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fin_migrate_form'),
    'access arguments' => array('administer site configuration'),
  );
  return $items;
}

/**
 * Implements hook_form().
 */
function fin_migrate_form() {
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Start import'),
  );

  return $form;
}

/**
 * Implements hook_form_submit().
 */
function fin_migrate_form_submit($form, &$form_state) {
  $batch = array(
    'title' => t('Importing data'),
    'operations' => array(),
    'finished' => '_fin_migrate_done',
  );
  //// PLW $state_user = fin_migrate_move_users($batch);
  //$state_node_step_1 = fin_migrate_do_step1($batch);
  $state_node_step_2 = fin_migrate_do_step2($batch);
  batch_set($batch);
}

/**
 * Handle the close of batch.
 */
function _fin_migrate_done() {
  $message = "DONE";
  watchdog('FIN_MIGRATE', $message, array(), WATCHDOG_INFO);
}

/* SECTION USERS
 * /////////////// USERS ////////////////
 */

/**
 * Implements hook_form_submit().
 */
function fin_migrate_move_users(&$batch) {
  ini_set('max_execution_time', 3600000);
  define('fin_migrate_USER_RID_NONE', '2');

  $oldnew = array();
  $newold = array();
  $nameslist = array();
  $uidmaps = array();
  $resuming = FALSE;

  $trialnewroles = array(2, 6);
  $newroles = array(
    '1' => 'anonymous users',
    '2' => 'authenticated user',
    '3' => 'administrator',
    '4' => 'editor',
    '5' => 'author',
    '6' => 'Trial Member',
    '7' => 'Basic Member',
    '8' => 'Family Office',
  );

  $rolemap = array(
    '1' => array(1),
    '2' => array(2, 7),
    '3' => array(2, 3),
    '4' => array(2, 5),
    '5' => array(2, 4),
    '6' => array(2, 6),
    '7' => array(2, 7),
    '8' => array(2, 9),
  );

  db_set_active('legacy');
  $sql = "select uid from {users} WHERE uid>7";
  $result = db_query($sql);
  db_set_active();
  // Oids are all old keys in source table, noids keys we saved
  // We will use array_diff to tell us what ids have not been done yet.
  $oids = array();
  $res = array();
  foreach ($result as $row) {
    $res[$row->uid] = $row->uid;
  }
  if ($res) {
    $oids = array_values($res);
  }
  $noids = array();
  if (isset($newold)) {
    $noids = array_values($newold);
  }
  $stufftomove = TRUE;
  $partial = FALSE;
  if ($noids) {
    $getids = array_diff($oids, $noids);
    if (!$getids) {
      $stufftomove = FALSE;
    }
    else {
      $partial = TRUE;
    }
  }
  $sql = '';
  if ($partial && $stufftomove) {
    $usql = "select uid, name, pass, mail, status, created, login from {users} where uid in (" . implode(",", $getids) . ") order by uid";
  }
  elseif (!$partial && $stufftomove) {
    // We are starting fresh with a table, use simpler SQL.
    $getids = array_keys($oids);
    $usql = "select uid, name, pass, mail, status, created, login from {users} where uid > 777 order by uid";
  }

  if ($stufftomove) {
    db_set_active('legacy');
    $inusers = db_query($usql)->fetchAll();
    db_set_active();

    if ($inusers) {

      $motion = "Starting Fresh ";
      if ($partial) {
        $motion = "Resuming ";
      }
      $start = time();

      // First, extract all Trial Members.
      $trial_uids = array();
      $sql = "select uid from accounttypes_users where atid=2 or atid=4";
      db_set_active('legacy');
      $result = db_query($sql);
      db_set_active();
      foreach ($result as $row) {
        $trial_uids[$row->uid] = $row->uid;
      }

      $profilesarr = array();
      $sql = "select * from {profile_values}";

      db_set_active('legacy');
      $raw = db_query($sql);
      db_set_active();

      foreach ($raw as $row) {
        $profilesarr[$row->uid][$row->fid] = $row->value;
      }

      $sql = "select u.uid as uid,r.rid as role from {users_roles} u, {role} r where u.rid=r.rid";
      db_set_active('legacy');
      $result = db_query($sql);
      db_set_active();
      $roleres = array();
      foreach ($result as $row) {
        $roleres[$row->uid][$row->role] = $row->role;
      }
      $noroles = array();
      $rolesuids = array_keys($roleres);
      $noroles = array_diff($getids, $rolesuids);
      foreach ($noroles as $norole) {
        $roleres[$norole][fin_migrate_USER_RID_NONE] = fin_migrate_USER_RID_NONE;
      }

      db_set_active();
      $userres = array();

      // SALESFORCE - get list of Emails to query SF with.
      $emails = array();
      $getemails = $inusers;
      foreach ($getemails as $row) {
        $emails[] = $row->mail;
      }

      $sfdata = '';
      $mailmismatches_active = array();
      $mailmismatches_inactive = array();
      $statusactivetoinactive = array();
      $statusinactivetoactive = array();
      foreach ($inusers as $keyyyy => $row) {
        $profile = FALSE;
        if (!isset($sfdata[$row->mail])) {
          $lastname = '';
          $firstname = '';
          $companyname = '';
          if (isset($profilesarr[$row->uid][1])) {
            $firstname = $profilesarr[$row->uid][1];
          }
          if (isset($profilesarr[$row->uid][2])) {
            $lastname = $profilesarr[$row->uid][2];
          }
          if (isset($profilesarr[$row->uid][3])) {
            $companyname = $profilesarr[$row->uid][3];
          }
          $profile = array(
            'id' => 0,
            'email' => $row->mail,
            'firstname' => $firstname,
            'lastname' => $lastname,
            'company' => $companyname,
            'inactive' => $row->status,
            'expiry_date' => '',
            'expiry' => 0,
            'title' => '',
            'homephone' => '',
            'mobilephone' => '',
          );
          $message = "D5 email not in SF, so we use D5 data instead. Email: " . $row->mail . "Data: " . print_r($profile, TRUE);

        }
        else {
          $profile = $sfdata[$row->mail];
        }

        $sfstatus = 0;

        $d5status = $row->status;

        $finalstatus = 0;

        if ($profile['expiry'] > 0) {
          // Determine status based on SF.
          $now = time();
          if ($profile['expiry'] > $now && !$profile['inactive']) {
            $sfstatus = 1;
            $finalstatus = 1;
          }

          // If D5 says active & SF says Inactive, or vice versa,
          // report the conflict.
          if ($sfstatus <> $d5status) {
            if ($d5status) {
              // Drupal user going from active to inactive.
              $statusactivetoinactive[$row->mail][] = $profile;
            }
            if ($sfstatus) {
              // Drupal user going from inactive to active.
              $statusinactivetoactive[$row->mail][] = $profile;
            }

            $profile['d5_status'] = $d5status;
            $profile['sf_status'] = $sfstatus;
            $profile['final_status'] = $finalstatus;
            $sfstatusstr = "INACTIVE";
            if ($sfstatus) {
              $sfstatusstr = "ACTIVE";
            }
            $oldstatusstr = "INACTIVE";
            if ($row->status) {
              $oldstatusstr = "ACTIVE";
            }
            $message = t('D5 says user %firstname %lastname ( %email ) is %oldstatus but Salesforce says status is %sfstatus. Inactive: %inactive Expiration Date: %expiry',
              array(
                '%email' => $row->mail,
                '%firstname' => $profile['firstname'],
                '%lastname' => $profile['lastname'],
                '%sfstatus' => $sfstatusstr,
                '%oldstatus' => $oldstatusstr,
                '%expiry' => date('m-d-y', $profile['expiry']),
                '%inactive' => $profile['inactive'],
              )
            );

            if ($finalstatus) {
              $statusinactivetoactive[$row->mail][] = $profile;
            }
            else {
              $statusinactivetoactive[$row->mail][] = $profile;
            }
          }
        }
        else {
          // If there is no expiry or no sf data.
          $finalstatus = $d5status;
          if ($finalstatus) {
            $mailmismatches_active[$row->mail][] = $profile;
          }
          else {
            $mailmismatches_inactive[$row->mail][] = $profile;
          }
        }

        $usr = array(
          'uid' => $row->uid,
          'name' => $row->name,
          'mail' => $row->mail,
          'pass' => $row->pass,
          'status' => $finalstatus,
          'login' => $row->login,
          'created' => $row->created,
        );
        $userres[$row->uid] = array_merge($usr, $profile);
        if ($keyyyy > 6018) {
        }
      }

      $rolesarr = array();
      foreach ($roleres as $uid => $roles) {
        $uidstr = (string) $uid;
        if (isset($trial_uids[$uidstr])) {
          foreach ($trialnewroles as $newrid) {
            $newridstr = (string) $newrid;
            $newrole = $newroles[$newridstr];
            $rolesarr[$uidstr][$newridstr] = $newrole;
          }
        }
        else {
          foreach ($roles as $rid) {
            $newrids = $rolemap[$rid];
            foreach ($newrids as $newrid) {
              $newridstr = (string) $newrid;
              $ind = (string) $rid;
              $newrole = $newroles[$ind];
              $rolesarr[$uidstr][$newridstr] = $newrole;
            }
          }
        }
      }

    }
  }
  foreach ($userres as $uid => $olduser) {
    if (empty($olduser['mail'])) {
      continue;
    }
    $uidstr = (string) $uid;
    $userroles = FALSE;
    if (isset($rolesarr[$uidstr])) {
      $userroles = $rolesarr[$uidstr];
    }
    $batch['operations'][] = array('_fin_migrate_batch_process_users',
      array($olduser, $userroles),
    );
  }
}

/**
 * Process Users batch.
 */
function _fin_migrate_batch_process_users(array $olduser, $userroles, &$context) {

  require_once 'includes/password.inc';

  $mail = (string) $olduser['mail'];
  if (substr($mail, 0, 1) == "@") {
    $oldmail = $mail;
    $mail = 'corrected' . $fname . '.' . $lname . $mail;
  }

  $oldpass = (string) $olduser['pass'];
  $newpass = 'qapla';
  $noroles = FALSE;
  if ($userroles) {
    $fields = array(
      'name' => $olduser['name'],
      'mail' => $olduser['mail'],
      'pass' => $newpass,
      'status' => $olduser['status'],
      'init' => $olduser['mail'],
      'roles' => $userroles,
      'created' => $olduser['created'],
      'access' => $olduser['login'],
    );
  }
  else {
    $message = "This User " . print_r($olduser, TRUE) . " does not have any roles. Something went wrong here";
    watchdog('FIN_MIGRATE', $message, array(), WATCHDOG_WARNING);
    $fields = array(
      'name' => $olduser['name'],
      'mail' => $olduser['mail'],
      'pass' => $newpass,
      'status' => $olduser['status'],
      'init' => (string) $olduser['mail'],
      'created' => $olduser['created'],
      'login' => $olduser['login'],
    );
  }

  // 013116 - for some reason there is a duplicate key error, remedy here.
  $curuser = user_load_by_mail($olduser['mail']);
  $uname = $olduser['name'];
  if ($curuser) {
    return;
  }
  if (!$curuser) {
    $acct = new stdClass();
    $acct->active = 1;

    $curuser = user_save($acct, $fields);

    $newuid = (int) $curuser->uid;
    $context['message'] = 'New user created with user id ' . $newuid;
    $nameslist[$uname] = $uname;
    $newpass = user_hash_password($oldpass);
    if ($newpass) {
      // Indicate an updated password.
      $newpass  = 'U' . $newpass;
    }

    db_update('users')->fields(array('pass' => $newpass))->condition('uid', $curuser->uid)->execute();

    $oldnew[$uid] = $newuid;
    $newold[$newuid] = $uid;

    $uidmaps = array();
    $uidmaps['oldnew'] = $oldnew;
    $uidmaps['newold'] = $newold;
    $uidmaps['nameslist'] = $nameslist;
  }

  // Plw 0116 now take care of organization & profile2, extract bio data first.
  $message = '';
  $username = (string) $olduser['name'];
  $email = (string) $olduser['mail'];
  $lastname = $olduser['lastname'];
  $firstname = $olduser['firstname'];
  $companyname = $olduser['company'];

  $organization_nid = 0;
  if ($companyname) {
    $organization_nid = _fin_migrate_get_entity_by_name('field_organization_name', $olduser['company'], 'organization', 'node');
    if (!$organization_nid) {
      try {
        $organization = entity_create('node',
          array('type' => 'organization', 'uid' => 1, 'status' => 1));
        $organization->field_organization_name[LANGUAGE_NONE][0]['value'] = $companyname;
        $organization->title = $companyname;
        entity_save('node', $organization);
        $organization_nid = $organization->nid;
        $message = t('Created new Organization %company from D5 Row: %data.',
          array(
            '%company' => $companyname,
            '%data' => print_r($row, TRUE),
          )
        );
      }
      catch (Exception $e) {
        $message = t('Failed to create organization %company from D5 Row: %data. Error: @msg<br /><br />%data',
           array(
             '%username' => $username,
             '%email' => $email,
             '%data' => print_r($row, TRUE),
             '@msg' => $e->getMessage(),
           )
         );
      }
      if ($message) {
        watchdog('FIN_MIGRATE_ORGANIZATION', $message, array(), WATCHDOG_INFO);
        $message = '';
      }
    }
  }

  $main_profile = fin_migrate_profile2_by_uid_load($newuid, 'main');
  if (!$main_profile) {
    $main_profile = entity_create('profile2', array('type' => 'main', 'node'));
  }
  $action = 'Update';
  if ($main_profile->uid) {
    $action = 'Create';
  }
  try {
    if (!$main_profile->uid && $uid) {
      $main_profile->uid = $uid;
      $message = t('Profile attached to a User. This should only happen w/new profiles. User %username ( %email ) UID %uid',
        array(
          '%username' => $username,
          '%email' => $email,
          '%uid' => $newuid,
        )
      );
    }
    $main_profile->field_pf_first_name[LANGUAGE_NONE][0]['value'] = $olduser['firstname'];
    $main_profile->field_pf_last_name[LANGUAGE_NONE][0]['value'] = $olduser['lastname'];
    $main_profile->field_pf_job_title[LANGUAGE_NONE][0]['value'] = $olduser['title'];
    $main_profile->field_pf_expiration_date[LANGUAGE_NONE][0]['value'] = $olduser['expiry'];
    if ($organization_nid) {
      $main_profile->field_pf_organization[LANGUAGE_NONE][0]['target_id'] = $organization_nid;
    }
    entity_save('node', $main_profile);

    $message = t('Successfully %action profile for user %username ( %email ) from D5 Row: %data.',
      array(
        '%action' => $action . 'd',
        '%username' => $username,
        '%email' => $email,
        '%data' => print_r($row, TRUE),
      )
    );
  }
  catch (Exception $e) {
    $message = t('Failed to %action profile for user %username ( %email ) from D5 Row: %data. Error: @msg',
      array(
        '%action' => $action,
        '%username' => $username,
        '%email' => $email,
        '%data' => print_r($row, TRUE),
        '@msg' => $e->getMessage(),
      )
    );
  }
  if ($message) {
    watchdog('FIN_MIGRATE_PROFILE2', $message, array(), WATCHDOG_INFO);
    $message = '';
  }
}

/*
 * HELPER FUNCTIONS FOR USERS
 */

/**
 * Create csv file reports for Salesforce Reconciliation.
 */
function _fin_migrate_make_csv($inarr) {
  if ($inarr) {
    $arr = array(
      'firstname',
      'lastname',
      'company',
      'email',
      'inactive',
      'expiry_date',
    );

    $header = FALSE;
    foreach ($inarr as $row_raw) {
      $row = array();
      foreach ($arr as $fld) {
        $row[$fld] = $row_raw[0][$fld];
      }
      if (!$header) {
        $out[] = '"' . implode('" , "', array_keys($row)) . '"';
        $header = TRUE;
      }
      $vals = array_values($row);
      $out[] = '"' . implode('" , "', $vals) . '"';
    }
    return implode("\r\n", $out);
  }
  return FALSE;
}

/**
 * Get salesforce data via their API.
 */
function _fin_migrate_get_sfdata($emails) {
  /*
   * Grab Salesforce datga
   */
  $params = array(
    'new-users' => array(
      'Contact' => array(
        'fields' => array(
          'Inactive__c' => 'inactive',
          'FINsearches_Expiration_New__c' => 'expiry',
          'FirstName' => 'firstname',
          'LastName' => 'lastname',
          'Email' => 'email' ,
          'Account.Name' => 'company',
          'Title' => 'title',
          'HomePhone' => 'homephone',
          'MobilePhone' => 'mobilephone',
        ),
        'types' => array(
          'Contact',
        ),
      ),
    ),
  );
  $sfapi = salesforce_get_api();
  $out = FALSE;
  foreach ($params as $pseudonym => $maps) {
    foreach ($maps as $sf_object_type => $map) {
      $mapped_fields = $map['fields'];
      $sf_object_type = $map['types'][0];
      $soql = new SalesforceSelectQuery($sf_object_type);

      // Convert field mappings to SOQL.
      $soql->fields = array('Id', 'LastModifiedDate');
      foreach ($mapped_fields as $field => $ignore) {
        $soql->fields[] = $field;
      }

      $chunks = array_chunk($emails, 400);
      foreach ($chunks as $chunk) {
        $soql->conditions = array();
        $soql->addCondition('Email', $chunk, 'IN');

        // Execute query.
        $results = $sfapi->query($soql);
        if (!isset($results['errorCode'])) {
          $rows = $results['records'];
          foreach ($rows as $row) {
            $email = $row['Email'];
            if ($email) {
              $arr = array();
              foreach ($row as $key => $val) {
                if ($key == "Account") {
                  $val = $val['Name'];
                  $alias = 'company';
                  $arr[$alias] = $val;
                }
                if (isset($mapped_fields[$key])) {
                  $alias = $mapped_fields[$key];
                  if ($alias == "expiry") {
                    $arr['expiry_date'] = $val;
                    $val = strtotime($val);
                  }
                  if ($alias == "company") {
                    $val = $val['Name'];
                  }
                  $arr[$alias] = $val;
                }
                elseif (($key == 'Id')) {
                  $arr['id'] = $val;
                }
              }
              $out[$email] = $arr;
            }
            else {
              $message = "MISSING EMAIL - Row: " . print_r($row, TRUE);
              watchdog('SF_MIGRATION_SF', $message, array(), WATCHDOG_ERROR);
            }
          }
        }
      } // if results
    } // each map
  } // all maps

  $message = "SF OUT: " . print_r($out, TRUE);
  watchdog('FIN_MIGRATE_SF', $message, array(), WATCHDOG_INFO);
  return $out;
}

/**
 * Load user by id.
 */
function fin_migrate_profile2_by_uid_load($uid, $type_name) {
  if ($uid && is_numeric($uid) && ($account = user_load($uid))) {
    $profile = profile2_load_by_user($account, $type_name);
    if (!$profile) {
      $profile = profile2_create(array('type' => $type_name, 'uid' => $uid));
      $profile->setUser($account);
      $profile->is_new = TRUE;
    }
    return $profile;
  }
  return FALSE;
}

/**
 * Load entity by entity title, lable.
 */
function _fin_migrate_get_entity_by_name($fieldname, $name, $bundle, $type) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', $type)
    ->entityCondition('bundle', $bundle)
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_organization_name', 'value', $name, '=');
  $result = $query->execute();

  $id = FALSE;
  if (isset($result['node'])) {
    $ids = array_keys($result['node']);
    if ($ids) {
      $id = $ids[0];
      return $id;
    }
  }
  return FALSE;
}
//////////////// END SECTION USERS /////////////////

/* SECTION STEP1
 * /////////////// Create bare nodes //////////////
 */

/**
 * Node part one batch wrapper.
 */
function fin_migrate_do_step1(&$batch) {
  ini_set('max_execution_time', 3600000);
  ini_set('memory_limit', '1024M');

  // Get Parameters.
  $nodemaparr = fin_migrate_get_nodemaps('step1');
  $movement = 0;
  $howmanymovements = count($nodemaparr);
  foreach ($nodemaparr as $maparr) {
    foreach ($maparr as $pseudonym => $map) {
      $movement++;

      $params = $map['params'];
      $table = $params['oldtable'];
      $dst = $params['dst'];
      $pkeyname = $params['oldkeyfldname'];
      $bundle = '';
      if (isset($params['bundle'])) {
        $bundle = $params['bundle'];
      }

      $checkname = FALSE;
      $namenids = array();
      $namefldname = '';
      $multiplestotal = FALSE;
      if (isset($params['checkname'])) {
        $namefldname = $params['checkname']['fldname'];
        $namenids = unserialize(variable_get('fin-migrate-contact-contactnames'));
        $multiplestotal = unserialize(variable_get('fin-migrate-contact-contactnames_total'));
        if (!$namenids) {
          $sql = "SELECT COUNT(*) AS cnt, " . $namefldname . " AS name FROM {" . $table . "} WHERE " . $namefldname . " <> '' GROUP BY " . $namefldname . " HAVING count( " . $namefldname . " ) >1";
          db_set_active('legacy');
          $res = db_query($sql);
          db_set_active();
          if ($res) {
            $multiplestotal = 0;
            foreach ($res as $rw) {
              $name = $rw->name;
              $cnt = $rw->cnt - 1;
              $multiplestotal += $cnt - 1;
              $namenids[$name] = array(
                'cnt' => $cnt,
                'hits' => 0,
                'nid' => 0,
              );
            }
            variable_set('fin-migrate-contact-contactnames', serialize($namenids));
            variable_set('fin-migrate-contact-contactnames_total', serialize($multiplestotal));
          }
        }
        $checkname = TRUE;
      }

      // See what ids to draw from a table.
      db_set_active('legacy');
      $sql = "select " . $pkeyname . " from {" . $table . "}";
      $result = db_query($sql);
      db_set_active();
      // Oids are all old keys in source table, noids keys we saved
      // We will use array_diff to tell us what ids have not been done
      // yet.
      $oids = array();
      $res = array();

      foreach ($result as $row) {
        $res[$row->$pkeyname] = $row->$pkeyname;
      }
      if ($res) {
        $oids = array_values($res);
      }
      $noids = array();
      if (isset($newold[$pseudonym])) {
        $raw = $newold[$pseudonym];
        $nid2ids = array();
        foreach ($raw as $nid => $more) {
          foreach ($more as $delta => $yetmore) {
            foreach ($yetmore as $id) {
              $noids[$id] = $id;
              $nid2ids[$nid][] = $id;
            }
          }
        }
      }
      $stufftomove = TRUE;
      $partial = FALSE;

      if ($noids) {
        $getids = array_diff($oids, $noids);

        if (!$getids) {
          $stufftomove = FALSE;
        }
        else {
          $partial = TRUE;
        }
      }
      $sql = '';
      if ($partial && $stufftomove) {
        $sql = "select * from {" . $table . "} where " . $pkeyname . " in (" . implode(',', $getids) . ")";
      }
      elseif (!$partial && $stufftomove) {
        // We are starting fresh with a table, use simpler SQL.
        $getids = array_keys($oids);
        $sql = "select * from {" . $table . "}";
      }

      if ($stufftomove) {
        $duplicates = array();
        if ($duplicates = unserialize(variable_get('fin-migrate-step1-duplicates'))) {
        }
        db_set_active('legacy');
        $result = db_query($sql);
        db_set_active();

        if ($result) {
          if ($getids) {
            $howmanyrows = count($getids);
          }
          else {
            $howmanyrows = count($oids) - count($noids);
          }
          $motion = "Moving ";
          if ($partial) {
            $motion = "Resuming ";
          }
          $message = $motion . $pseudonym . " SOURCE (" . count($oids) . ") | MOVED: " . count($noids) . " | MOVING: " . $howmanyrows;
          watchdog('FIN_MIGRATE_NODE-' . $pseudonym, $message, array(), WATCHDOG_INFO);
          $prefix = "Step (1/2) Movement (" . $movement . "/" . $howmanymovements . ") " . $message;

          $start = time();
          foreach ($result as $row) {
            $batch['operations'][] = array('_fin_migrate_process_batch_step1',
              array(
                $pseudonym,
                $dst,
                $table,
                $pkeyname,               
                $row,
                $checkname,
                $namefldname,
                $pkeyname,
              ),
            );
          } // each row
        } // if result
      }
    } // foreach pseudonym
  }
  return TRUE;
}

/**
 * Process Step1 Batch
 */
function _fin_migrate_process_batch_step1($pseudonym, $dst, $table, $pkeyname, $row, $checkname, $namefldname, $pkeyname, &$context) {

  $id = $row->$pkeyname;
  $nid = 0;
  // Are we setting up contacts? Does this contact-by-email-address exist?
  if ($checkname) {
    $contactname = $row->{$namefldname};
    if (isset($namenids[$contactname])) {
      $nid = $namenids[$contactname]['nid'];
      if ($nid) {
        $message = "Contact exist. " . $pseudonym . " Name " . $contactname . " Update NID: " . $nid . " | ID: " . $id;
        watchdog('FIN_MIGRATE_BATCH_CONTACT_NAME_MULTIPLE', $message, array(), WATCHDOG_INFO);
        $contactmatches = array();
        $contactmatches[] = '"' . $contactname . '", "' . $id . '", "' . $nid . '"';

        $duplicates[$nid]['name'][$contactname][$id] = array(
          'id' => $id,
          'nid' => $nid,
          'name' => $contactname,
          'type' => $dst,
          'bundle' => $bundle,
        );
        // Disable because this part can potentially slow down the system.
        // We are serializing and updating whole array in databaes every time
        // for a single node duplication.
        // variable_set('fin-migrate-step1-duplicates', serialize($duplicates));
      }
    }
  }
  if (!$nid) {
    $created = strtotime($row->CreatedOn);
    $changed = strtotime($row->UpdatedOn);
    if ($created < 0 or !is_numeric($created)) {
      $bad = $created;
      $created = $changed;
      if ($created < 0 or !is_numeric($created)) {
        $bad2 = $created;
        $created = time();
        $changed = $created;
      }
    }
    elseif ($changed < 0 or !is_numeric($created)) {
      $bad = $changed;
      $changed = $created;
    }

    if ($dst=="contact") {
        $title = "contactmigration|".$pseudonym."|".$id . "|" . $contactname;
    } else {
        $title = "migration|".$pseudonym . "|" . $id;
    }   
    $values = array(
      'title' => $title,
      'type' => $dst,
      'uid' => 1,
      'status' => 1,
      'promote' => 0,
      'created' => $created,
      'changed' => $changed,
    );
    $entity = entity_create('node', $values);
    $n_wrapper = entity_metadata_wrapper('node', $entity);
    $n_wrapper->save();
    $nid = (int) $n_wrapper->getidentifier();

    if ($nid) {
/*
      $oldnew = array();
      $newold = array();
      $variable = 'fin-migrate-node';
      $oldnews = fin_migrate_get_best_map($variable);
      if ($oldnews) {
        $oldnew = unserialize($oldnews['oldnew']);
        $newold = unserialize($oldnews['newold']);
      }

      $oldnew[$pseudonym][$id][$nid] = $nid;
      //012816
      //Because we consolidate contacts, new may link to multi old records
      //$newOld[$pseudonym][$nid][$id] = $id;
      $newold[$pseudonym][$nid][][$id] = $id;
      fin_migrate_update_map($variable, $oldnew, $newold);
*/
      if ($checkname) {
        $nameNids = unserialize(variable_get('fin-migrate-contact-contactnames'));
        if (isset($namenids[$contactname])) {
          $namenids[$contactname]['nid'] = $nid;
          if (isset($namenids[$contactname])) {
            $namenids[$contactname]['hits']++;
            if (empty($namenids[$contactname]['nid'])) {
              $namenids[$contactname]['nid'] = $nid;
            }
            variable_set('fin-migrate-contact-contactnames', serialize($namenids));
          }
          $message = "Contact Node (".$nid.") created for Multiple Contact ".$contactName;
          watchdog('FIN_MIGRATE_CONTACT_MULTIPLE', $message, array(), WATCHDOG_INFO);
        }
      }

      $context['message'] = 'Created a new ' . $n_wrapper->value()->type . '  node with nid ' . $n_wrapper->value()->nid;

    }
    else {
      // Disabled since we are not need it for now.
      // $message = "Oops, for some reason, node not successfully created | id: "
      // $message .= $id." | nid: ".$nid." | Data: ".print_r($row,true);
      // watchdog('FIN_MIGRATE_NODE_STEP1', $message, array(), WATCHDOG_WARNING);
    }
  } // if row produced ids
} // each row

/**
 * Get content field mapping for migration.
 */

/**
 * Check drupal variable map.
 *
 * Function that checks Drupal Variable Store for ongoing maps/node progress
 * list. For Found 1 Node transfers, we maintain 2 copies of old ID/NID lists,
 * for Round 2, Similar lists tracking what nodes are filled out. We maintain a
 * double set of each for fault tolerance, since both of these sets of numbers
 * are mission-critical.
 *
 * @parameters
 *  $var1 - the variable name of the 1st copy of the list
 *  $var2 - the name of the backup copy
 *  $check1 - the newold list
 *  $check2 - the oldnew list
 */
function fin_migrate_get_best_map($name = 'fin-migrate-node') {
  $name1 = $name . '1';
  $name2 = $name . '2';
  // PLW 090115 first thing to figure out whether we are beginning or resuming.
  // Its a bit complicated. We have 2 variables set at different times so if
  // 1 is interrupted during an update, the other survives. We can have a busted
  // variable, or w/in a variable, a busted new/old key map.
  $proceed = FALSE;
  $out = array();
  if ($out = unserialize(variable_get($name2))) {
    // So far, so good. But old/new key map may be corrupted. Check for it.
    if (isset($out['oldnew']) && isset($out['newold'])) {
      $proceed = TRUE;
    }
  }
  // Okay, something went wrong and the updated data was irretrievable, lets try
  // the backup set.
  if (!$proceed) {
    // Uncap when done.
    if ($out = unserialize(variable_get($name1))) {
      // So far, so good. But old/new key map may be corrupted. Check for it.
      if (isset($out['oldnew']) && isset($out['newold'])) {
        $message = "Recovering from an abort or failure. Deleting latest node and using 1 node old data - ";
        watchdog('FIN_MIGRATE_OLDNEW', $message, array(), WATCHDOG_WARNING);
      }
    }
  }
  return $out;
}

function profile2_by_uid_load($uid, $type_name) {
  if ($uid && is_numeric($uid) && ($account = user_load($uid))) {
    $profile = profile2_load_by_user($account, $type_name);
    if (!$profile) {
      $profile = profile2_create(array('type' => $type_name, 'uid' => $uid));
      $profile->setUser($account);
      $profile->is_new = TRUE;
    }
    return $profile;
  }
  return FALSE;
}


/* SECTION Step2
 * //////////////////// STEP2 /////////////////////
 */
function fin_migrate_do_step2(&$batch) {
  ini_set('max_execution_time', 3600000);
  ini_set('memory_limit','1024M');

  // Build New Old & Old New w/latest step1 content
  _fin_migrate_add_step1_nodes_to_oldnew();

  // Get Parameters
  $nodeMapArr = _get_nodemaps('step2');

  // Array containing old, new taxonomies
  $termMap = array(
    'Inactive' => array(
      'values' => array('0' => 'Inactive', '1' => 'Active'),
      'oldfldname' => 'Inactive',
      'oldterms' => array(),
      'newvoc' => '5',
      'newterms' => array(),
    ),
    'AssetClassID' => array(
      'table' => 'tblassetclasses',
      'oldfldname' => 'AssetClassID',
      'termfield' => 'AssetClassName',
      'oldterms' => array(),
      'newvoc' => '9',
      'newterms' => array(),
    ),
    'ClientTypeID' => array(
      'table' => 'tblclienttypes',
      'oldfldname' => 'ClientTypeID',
      'termfield' => 'ClientTypeName',
      'newvoc' => '8',
      'newterms' => array(),
    ),
    'ConsultantTypeID' => array(
      'table' => 'tblconsultanttypes',
      'oldfldname' => 'ConsultantTypeID',
      'termfield' => 'ConsultantTypeName',
      'oldterms' => array(),
      'newvoc' => '4',
      'newterms' => array(),
    ),
    'ConsultantOfficeID' => array(
      'table' => 'tblconsultantoffices',
      'oldfldname' => 'ConsultantOfficeID',      
      'termfield' => 'ConsultantOfficeName',
      'oldterms' => array(),
      'newvoc' => '3',
      'newterms' => array(),
    ),
    'CurrencyID' => array(
      'table' => 'tblcurrency',
      'oldfldname' => 'CurrencyID',
      'termfield' => 'FullName',
      'oldterms' => array(),
      'newvoc' => '11',
      'newterms' => array(),
    ),
    'DatabasesUsedID' => array(
      'table' => 'tbldatabasesused',
      'oldfldname' => 'DatabasesUsedID',
      'termfield' => 'DatabasesUsedName',
      'oldterms' => array(),
      'newvoc' => '10',
      'newterms' => array(),
    ),
    'FundTypeID' => array(
      'table' => 'tblfundtypes',
      'oldfldname' => 'FundTypeID',
      'termfield' => 'FundType',
      'oldterms' => array(),
      'newvoc' => '12',
      'newterms' => array(),
    ),
    'GeographicID' => array(
      'table' => 'tblgeographic',
      'oldfldname' => 'GeographicID',
      'termfield' => 'GeographicName',
      'oldterms' => array(),
      'newvoc' => '16',
      'newterms' => array(),
    ),
    'MajorStyleID' => array(
      'table' => 'tblmajorstyles',
      'oldfldname' => 'MajorStyleID',
      'termfield' => 'MajorStyle',
      'oldterms' => array(),
      'newvoc' => '',
      'newterms' => array(),
    ),
    'MinorStyleID' => array(
      'table' => 'tblminorstyles',
      'oldfldname' => 'MinorStyleID',
      'termfield' => 'MinorStyle',
      'oldterms' => array(),
      'newvoc' => '',
      'newterms' => array(),
    ),
    'OfficeType' => array(
      'values' => array('0'=>'Main', '1'=>'Branch'),
      'oldfldname' => 'OfficeType',
      'oldterms' => array(),
      'newvoc' => '3',
      'newterms' => array(),
    ),
    'PlacementPolicy' => array(
      'table' => 'tblplacementpolicies',
      'oldfldname' => 'PlacementPolicy',
      'termfield' => 'PlacementPolicyName',
      'oldterms' => array(),
      'newvoc' => '14',
      'newterms' => array(),
    ),
    'SourceID' => array(
      'table' => 'tblsources',
      'oldfldname' => 'SourceID',
      'termfield' => 'Source',
      'oldterms' => array(),
      'newvoc' => '',
      'newterms' => array(),
    ),
    'oldtaxonomy' => array(
      'newterms' => array(),
      'terms' => array(),
    ),
  );
  // END TERM MAP ARRAY

  $movement = 0;
  $howManyMovements = count($nodeMapArr);
  foreach ($nodeMapArr as $mapArr) {
    foreach ($mapArr as $pseudonym => $map) {
      $movement++;
      $context['message'] = "Step (2/2) Movement (".$movement."/".$howManyMovements.") Moving ".$pseudonym;

      $params = $map['params'];
      $table = $params['oldtable'];
      $dst = $params['dst'];
      $pKeyName = $params['oldkeyfldname'];    

      $oldNew_ref = array();
      $newOld_ref = array();
      $varname = 'fin-migrate-node';
      $oldNews_ref = _fin_migrate_get_best_map($varname);
      // we need the below in this function
      $oldNew_ref = unserialize($oldNews_ref['oldnew']);
      $newOld_ref = unserialize($oldNews_ref['newold']);

      //if this is resuming, grab current old new map
      $oldNew = array();
      $newOld = array();
      $variable = 'fin-migrate-done';
      $oldNews = _fin_migrate_get_best_map($variable);
      if ($oldNews) {
        $oldNew = unserialize($oldNews['oldnew']);
        $newOld = unserialize($oldNews['newold']);
      }
      
      // Contacts require completely different handling
      if ($dst=='contact') {
        fin_migrate_do_step2a($pseudonym, $map, $termMap, $newOld, $oldNew);
      } else {
        // see what ids to draw from a table
        db_set_active('legacy');
        $sql = "select ".$pKeyName." from {".$table."}";
        $result = db_query($sql);
        db_set_active();
        // oids are all old keys in source table, noids keys we saved
        // We will use array_diff to tell us what ids have not been done
        // yet.
        $oids = array();
        $res = array();
        foreach ($result as $row) {
          $res[$row->$pKeyName] = $row->$pKeyName;
        } 
        if ($res) {
          $oids = array_values($res);
        }
        $noids = array();
        if (isset($newOld[$pseudonym])) {
          $noids = array_values($newOld[$pseudonym]);
        }
        $stuffToMove = TRUE;
        $partial = FALSE;
        if ($noids) {
          $getids = array_diff($oids, $noids);
          if (!$getids) {
            $stuffToMove = FALSE;
          } else {
            $partial = TRUE;
          }
        }
        $sql = '';
        if ($partial && $stuffToMove) {
          $sql = "select * from {".$table."} where ".$pKeyName." in (".implode(',',$getids).")";
        } else if (!$partial && $stuffToMove) {
          // we are starting fresh with a table, use simpler SQL
          $getids = array_keys($oids);
          $sql = "select * from {".$table."}";
        }
        if ($stuffToMove) {
          db_set_active('legacy');
          $result = db_query($sql);
          db_set_active();
        }

        if ($result) {
          $howManyRows = $result->rowCount();
          $rowCount=0;
          $motion = "Moving ";
          if ($partial) {
            $motion = "Resuming ";
          }
          $message = "Step (2/2) ".$motion." ".$pseudonym." SOURCE (".count($oids).") | EDITED: ".count($noids)." | EDIING: ".$howManyRows;
          watchdog('FIN_MIGRATE_NODE-'.$pseudonym, $message, array(), WATCHDOG_INFO);
          $prefix = "Step (1/2) Movement (".$movement."/".$howManyMovements.") ".$message;
          $context['message'] = $prefix;

          $rowCount = 0;
          $start = time();
          foreach ($result as $row) {

if ($rowCount>40) {
  $stop = time();
  $elapsed = $stop-$start;
  die("Step2 Type: ".$dst."| Elapsed time: ".$elapsed." Seconds. Count: ".$rowCount."-Step2 - Another 6000 complete, start next");
}

            $context['progress'] = (int) ($rowCount/$howManyRows)*100;
            $context['message'] = 'Movement ('.$movement.'/'.$howManyMovements.') Moving '.$pseudonym.'... Row ('.$rowCount.'/'.$howManyRows.')...';
            $context['progress'] = ($rowCount/$howManyRows)*100;
            $id = (int) $row->$pKeyName;
            $nid = _fin_migrate_gotIdgetNid($id, $pseudonym, $oldNew);
            if ($id && $nid) {
              // The entity is now created, but we have not yet simplified use of it.
              // Now create an entity_metadata_wrapper around the new node entity
              // to make getting and setting values easier
              
              $entity = entity_load('node', array($nid));              
              if (!$entity) {
                $message = "ENTITY ID: ".$id." NID: ".$nid." NOT loaded. Element: ".print_r($entity,true)."--";
                watchdog('FIN_MIGRATE_NODE_'.$pseudonym.'-STEP 2', $message, array(), WATCHDOG_ERROR);
              }
              //$node = node_load(array($nid));
              //$entity_raw = entity_load('node', array($nid));
              //$entity = $entity_raw[$nid];                            
              $node = node_load($nid);
              $entity = $node;
              $wrapper = entity_metadata_wrapper('node', $node);
              //$wrapper = entity_metadata_wrapper('node', array($entity));
              //_fin_migrate_handler_system($map['system'], $row, $node, $termMap);
              _fin_migrate_handler_system($map['system'], $row, $wrapper, $entity, $termMap);
              //_fin_migrate_handler_system($map['system'], $row, $wrapper, $node, $termMap);

              $wrapper->save();
              // currently we only have fields section to process
              $fields = $map['fields'];
              _fin_migrate_process_fields($fields, $row, $wrapper, $entity, $termMap, $pKeyName, $id);

              $wrapper->save();

              $oldNew[$pseudonym][$id] = $nid;
              $newOld[$pseudonym][$nid] = $id;
              _fin_migrate_update_map($variable, $oldNew, $newOld);
            } else {
              $message = "Oops, for some reason, node not successfully created | id: ".$id." | nid: ".$nid." | Data: ".print_r($row,true);
              watchdog('FIN_MIGRATE_NODE_STEP2', $message, array(), WATCHDOG_WARNING);
            } // if row produced ids
          $rowCount++;
          } // each row
        } // if result
      }
    }
  }
}

/* SECTION STEP2A - Special Handling for Contacts
 * ////////////////// STEP 2A //////////////////////////
 */
/*
 * Special Handling for all d5 contact data
 *
 * Combine all Contact Tables into a single large array, process array.
 * Populate Step1 contact nodes w/basic information, use the rest to
 * create the Job History.
 */
function fin_migrate_do_step2a($pseudonym, $map, $termMap, &$newOld_ref, &$oldNew_ref) {
  $variable = 'fin-migrate-contacts_done';
  $done = unserialize(variable_get($variable));
  if (!$done) {
    $done = array();
  }

  $variable = 'fin-migrate-node';
  $oldNews = _fin_migrate_get_best_map($variable);
  if ($oldNews) {
    $oldNew_ref = unserialize($oldNews['oldnew']);
    $newOld_ref = unserialize($oldNews['newold']);
  }
 
  $variable = 'fin-migrate-contact-contactnames';
  $nameNids = unserialize(variable_get('fin-migrate-contact-contactnames'));

  $arrs = array();
  $arrs = _fin_migrate_prep_employment_dates($done);
  $names = $arrs['names'];
  $jobs = $arrs['jobs'];

  if ($jobs) {
    $howManyRows = count($jobs);
    $motion = "Moving ";
    if ($done) {
      $motion = "Resuming ";
    }
    $rowCount = 0;
    $paragraphCount = 0;
    $start = time();
    
    foreach ($jobs as $contactName => $row) {
      // The first thing we do, get nid, load contact, do contact properties
      $nid = $nameNids[$contactName]['nid'];

      //Now that we have a person jobs, let aggregate pictures and bio
      $scoop = $row;
      $picture = '';
      $bio = '';
      $firstRow = TRUE;
      $sysArr = array();
      foreach ($scoop as $start => $more) {
        foreach ($more as $tbl => $yetmore) {
          foreach ($yetmore as $rowid => $data) {
            if (!$bio && !empty($data['Bio'])) {
              $bio = $data['Bio'];
            }
            if (!$picture && isset($data['Picture']) and !empty($data['Picture'])) {
              $picture = $data['Picture'];
            }
            if ($firstRow) {
              $sysArr = $data;
              $firstRow = FALSE;
            }
          }
        }
      }
      $sysArr['Bio'] = $bio;
      $sysArr['Picture'] = $picture;
      $sysData = (object) $sysArr;

      //$node = node_load(array($nid));
      //$entity_raw = entity_load('node', array($nid));
      //$entity = $entity_raw[$nid];                            
      //$entity = entity_load('node', array($nid));                      
      $node = node_load($nid);
      $oldTitle = $node->title;
      $wrapper = entity_metadata_wrapper('node', $node);

      // we want to pass in both entity and wrapper, just keeping true to naming
      $entity = $node;
      // Basic Contact Node data populated here
      _fin_migrate_handler_system($map['system'], $sysData, $wrapper, $entity, $termMap);
      
      $newTitle = $wrapper->title_field;

      $jobMap = $map['job-history'];
      $params = $jobMap['params'];
      $hostFldName = $params['hostfield'];
      $bundles = $jobMap['bundles'];
      $wrappers = array();
      foreach ($row as $start => $tblarr) {
        foreach ($tblarr as $tbl => $idarr) {
          $fields = $bundles[$tbl]['fields'];        
          foreach ($idarr as $id => $data) {
            $inData = (object) $data;
          
            // Now, we call the function to create the paragraphs
            $paragraph = $bundles[$tbl];
            $bundle = $paragraph['params']['bundle'];
            $deferSave = FALSE;
            // only needed if we will query another table, not this time
            $keyName = '';
            $keyVal = 0;
            $wrapperArr = _fin_migrate_handler_paragraph($bundle, $hostFldName, $paragraph, $inData, $wrapper, $entity, $termMap, $keyName, $keyVal, $deferSave);       
            //even done one at a time, a single product is wrapped in an box, or array
            $wrappers[] = $wrapperArr[0];
          }
        }
      }
     
     //The Contact and its Job History have been built, save everything now
     //foreach ($wrappers as $p_wrapper) {
     //  $p_wrapper->save();
     //}
     //$wrapper->save();

     $oldNew[$pseudonym][$id] = $nid;
     $newOld[$pseudonym][$nid] = $id;
     _fin_migrate_update_map($variable, $oldNew, $newOld);
     $rowCount++;

     $message = t("Old Title: %oldtitle | New Title: %newtitle", array(
       'oldtitle' => $oldTitle,
       'newtitle' => $newTitle,
     ));
     watchdog('FIN_MIGRATE_CONTACT_NODE_UPDATED', $message, array(), WATCHDOG_INFO);

if ($rowCount>10) {
  $stop = time();
  $elapsed = $stop-$start;
  die("Elapsed time: ".$elapsed." Seconds. Count: ".$rowCount."-Step2 - Another 6000 complete, start next");
}
      
     $context['progress'] = (int) ($rowCount/$howManyRows)*100;
     $context['message'] = 'Movement ('.$movement.'/'.$howManyMovements.') gMoving '.$pseudonym.'... Row ('.$rowCount.'/'.$howManyRows.')...';
     $context['progress'] = ($rowCount/$howManyRows)*100;
             
     if (!$entity) {
       $message = "ENTITY ID: ".$id." NID: ".$nid." NOT loaded. Element: ".print_r($entity,true)."--";
       watchdog('FIN_MIGRATE_NODE_'.$pseudonym.'-STEP 2', $message, array(), WATCHDOG_ERROR);
     }

    } // each row
  } //if result
} // end function




 /*
 * Function to calculate Employment dates w/CreatedOn & UpdatedOn fields
 *
 * @Summary - The old database does not provide employment dates. So 
 * this function uses CreatedOn and UpdatedOn dates from each record in
 * tables tblconsultantcontacts, tblfundcontacts, tblmanagercontacts to
 * Calculate them.  Logic is as follow:
 * 
 * For Each record = a job
 * All Job Start Date = CreatedOn, in Unix format (# of seconds since 1/1/1970
 * For the most recent job, end = updatedOn if inactive=1, 0 otherwise
 * For other jobs, end = previous createdOn - 1 day, all set to inactive
 *
 * UPDATE: Original plan was a specific purpose task, but now it expanded
 * to process fields as well, given the map and term map as input.  So not 
 * do we build an array of employemt dates, but also embed translated, migrated
 * data with data assigned to the destination fields.  This way, the heavy lifting is
 * done at once and it simplifies the code that acxtually creates the paragraphs.
 */
function _fin_migrate_prep_employment_dates($done) {
  $arr = array();
  $tbl = 'tblconsultantcontacts';
  $id = 'ConsultantContactID';
  _fin_migrate_grab_job_data($tbl, $id, $arr, $done);

  $tbl = 'tblfundcontacts';
  $id = 'FundContactID';
  _fin_migrate_grab_job_data($tbl, $id, $arr, $done);

  $tbl = 'tblmanagercontacts';
  $id = 'ManagerContactID';
  _fin_migrate_grab_job_data($tbl, $id, $arr, $done);

  // now we have a full array, build an array of distinct contact names
  $contactNames = array();
  foreach ($arr as $contactName => $ignore) {
    $contactNames[$contactName] = $contactName;
  }

  // now, start filling in start & end dates in dates array
  // We sort each set in reverse order, so we can harvest the start date of one job
  // for the next record
  // If you are curious, 86400 is the number of seconds in 1 day, I added 60 seconds
  // to it so a midnight start date becomes 11:59PM the day before
  foreach ($contactNames as $contactName) {
    $set = $arr[$contactName];
    krsort($set);
    $solo = TRUE;
    if (count($set)>1) {
      $solo = FALSE;
    }
    $firstRow = TRUE;
 
    foreach ($set as $start => $more) {
      foreach ($more as $tbl => $yetmore) {
        foreach ($yetmore as $rowid => $data) {
          //$arr[$contactName][$start][$tbl][$rowid]['start'] = strtotime($data['createdon']);
          //$arr[$contactName][$start][$tbl][$rowid]['start'] = strtotime($data['createdon']);
          $inactive = (int) $data['Inactive'];
          $updatedOn = strtotime($data['UpdatedOn']);

          if ($solo) {
            if ($inactive) {
              $arr[$contactName][$start][$tbl][$rowid]['end'] = strtotime($data['UpdatedOn']);
            }
          } else {
            //multiple rows
            if ($firstRow) {
              if ($inactive) {
                $end = strtotime($data['UpdatedOn']);
              } else {
                $end = 0;
              }
              $firstRow = FALSE;
              $nextEndDate = $start-86400;
            } else {
              // This Job data may have been updated during a contacts
              // new job. We want jobs to be a stack of pancakes, not
              // the family tree of incestuous time travelers
              if ($inactive && $updatedOn<$nextEndDate) {
                $end = strtotime($data['UpdatedOn']);
              } else {
                $end = $nextEndDate;
              }
              $arr[$contactName][$start][$tbl][$rowid]['inactive'] = 1;              
              $nextEndDate = $start-86460;
            }
            $arr[$contactName][$start][$tbl][$rowid]['end'] = $end;          
          }
        }
      }
    }
  }
  
  /* deprecate
  // now that we are done with the sorting field, transfer
  // to a new array we can access easily later on
  //$jobs = array();
  $names = array();
  foreach ($arr as $contactName => $more) {
    foreach ($more as $sort => $yetmore) {
      foreach ($yetmore as $tbl => $evenmore) {
        foreach ($yetmore as $rowid => $data) {
          //$jobs[$contactName][$tbl][$rowid] = $data;
          $names[$contactName] = array(
            'tbl' => $tbl,
            'rowid' => $rowid,
          );
        }
      }
    }
  }
  */

  $out = array('jobs'=>$arr, 'names'=>$contactNames);
  return $out;
}

function _fin_migrate_grab_job_data($tbl, $id, &$out, $done) {
  $doneStr = '';
  if ($done) {
    $doneStr = "'".implode("','", $done)."'";
  }

  switch($tbl) {
    case 'tblconsultantcontacts':
      $sql = "SELECT ContactName, %id as id, Inactive, Title, CreatedOn, UpdatedOn, Fax, Phone, Email, Address, City, StateID, CountryID, ZIP, Picture, Bio, ConsultantFirmID as er, ConsultantOfficeID, ConsultantType from {%tbl} %where";
    break;
    case 'tblfundcontacts':
      $sql = "SELECT ContactName, %id as id, Inactive, Title, CreatedOn, UpdatedOn, Fax, Phone, Email, Address, City, StateID, CountryID, ZIP, Picture, Bio, FundID as er from {%tbl} %where";
    break;
    case 'tblmanagercontacts':
      $sql = "SELECT c.ContactName, %id as id, c.Title as Title, c.CreatedOn as CreatedOn, c.UpdatedOn as UpdatedOn, c.Fax as Fax, c.Phone as Phone, c.Email as Email, c.Picture as Picture, c.ManagerFirmID as er, CONCAT(m.Address1, m.Address2, m.Address3) as Address, m.City as City, m.ZIP as ZIP, m.StateID as StateID,  m.CountryID as CountryID from tblManagerContacts c, tblManagerFirms as m WHERE c.ManagerFirmID=m.ManagerFirmID %andwhere";
    break;
  }
  $sql = str_replace('%id', $id, $sql);
  $sql = str_replace('%tbl', $tbl, $sql);
  if ($doneStr) {
    $sql = str_replace('%where', 'WHERE ContactName NOT IN ('.$doneStr.')', $sql);
    $sql = str_replace('%andwhere', ' AND WHERE ContactName NOT IN ('.$doneStr.')', $sql);
  } else {
    $sql = str_replace('%where', '', $sql);
    $sql = str_replace('%andwhere', '', $sql);
  }

  db_set_active('legacy');
  $res = db_query($sql);
  db_set_active();
  if ($res) {
    foreach ($res as $row) {
      //use 
    $address = '';
    $city = '';
    $stateID = '';
    $countryID = '';
    $zip = '';
    $address = $row->Address;
    $city = $row->City;
    $stateID = $row->StateID;
    $countryID = $row->CountryID;
    $zip = $row->ZIP;
    if ($tbl=='tblmanagercontacts') {
      $inactive = 0;
      $bio = '';
    } else {
      $inactive = $row->Inactive;
      $bio = $row->Bio;
    }     
    $rowid = $row->id;
    $contactName = $row->ContactName;
    $title = $row->Title;
    $er = $row->er;
    $er2 = 0;
    $consultantType = 0;
    $consultantOfficeID = 0;
    if ($tbl=='tblconsultantcontacts') {
      $consultantOfficeID = $row->ConsultantOfficeID;
      $consultantType = $row->ConsultantType;
    }

    $start = strtotime($row->CreatedOn);
    $out[$contactName][$start][$tbl][$rowid] = array(
      'ContactName' => $contactName,
      'CreatedOn' => $row->CreatedOn,
      'Inactive' => $inactive,
      'UpdatedOn' => $row->UpdatedOn,
      'start' => $start,
      'end' => 0,
      'Title' => $title,
      'Address' => $address,
      'City' => $city,
      'ZIP' => $zip,
      'StateID' => $stateID,
      'CountryID' => $countryID,
      'Phone' => $row->Phone,
      'Fax' => $row->Fax,
      'Email' => $row->Email,
      'Picture' => $row->Picture,
      'Bio' => $bio,
      'er' => $row->er,
      'ConsultantOfficeID' => $consultantOfficeID,
      'ConsultantType' => $consultantType,
      );
    }
  }
}

/* SECTION OLDNEW - link nodes, collections, paragraphs to source table/ids
 * ///////////////////////// OLDNEW //////////////////////////
 */
function _fin_migrate_prep_terms(&$termMap) { 
  // Fill taxonomy array with new terms
  foreach ($termMap as $pseudonym => $settings) {
    $termIDField = $settings['oldfldname'];
    $out = array();
    if ( isset($settings['table']) ) {
      $id = $termIDField;
      $name = $settings['termfield'];
      $table = $settings['table'];
      db_set_active('legacy'); // Switch databases.
      $sql = "select ".$id." as id, ".$name." as name from {".$table."}";
      $terms = db_query($sql);
      db_set_active();
      foreach ($terms as $term) {
        $out[$term->id] = $term->name;
      }
    }
    else {
      $terms = $settings['values'];
      foreach ($terms as $id => $name) {
        $out[$id] = $name;
      }
    }
    $termMap[$termIDField]['oldterms'] = $out;

    $out = array();
    $vid = $settings['newvoc'];
    if ($vid) {
      $terms = entity_load('taxonomy_term', FALSE, array('vid' => $vid));
      foreach ($terms as $term) {
        $out[$term->name] = $term->tid;
      }
      $termMap[$termIDField]['newterms'] = $out;
      $termMap[$termIDField]['newvoc'] = $vid;  
    }
  }
}

/*
 * Function that checks Drupal Variable Store for ongoing maps/node progress list.
 * For Found 1 Node transfers, we maintain 2 copies of old ID/NID lists, for Round 2,
 * Similar lists tracking what nodes are filled out. We maintain a double set of each
 * for fault tolerance, since both of these sets of numbers are mission-critical.
 * 
 * @parameters
 *  $var1 - the variable name of the 1st copy of the list
 *  $var2 - the name of the backup copy
 *  $check1 - the newold list
 *  $check2 - the oldnew list
 */
function _fin_migrate_get_best_map($name='fin-migrate-node') {
  $name1 = $name .'1';
  $name2 = $name . '2';
  // PLW 090115 first thing to figure out whether we are beginning or resuming.
  // Its a bit complicated. We have 2 variables set at different times so if
  // 1 is interrupted during an update, the other survives. We can have a busted
  // variable, or w/in a variable, a busted new/old key map.
  $proceed = FALSE;
  $out = array();
  if ( $out = unserialize(variable_get($name2)) ) {
    // so far, so good. But old/new key map may be corrupted. Check for it.
    if ( isset($out['oldnew']) && isset($out['newold']) ) {
      $proceed = TRUE;
    }
  }
  // okay, something went wrong and the updated data was irretrievable, lets try the backup set
  if (!$proceed) {
    // uncap when done 
    //variable_set('fin-migrate-node2', array());
    if ( $out = unserialize(variable_get($name1)) ) {
      // so far, so good. But old/new key map may be corrupted. Check for it.
      if ( isset($out['oldnew']) && isset($out['newold']) ) {        
        $message = "Recovering from an abort or failure. Deleting latest node and using 1 node old data - ";
        watchdog('FIN_MIGRATE_OLDNEW',$message,array(),WATCHDOG_WARNING);   
      }
    }
  }
  // If both come up blank, this is a new migration, not a resumption
  return $out;
}

function _fin_migrate_update_map($name, $oldNew, $newOld) {
  $var1 = $name .'1';
  $var2 = $name . '2';
  $saveArr = array(
    'oldnew' => serialize($oldNew),
    'newold' => serialize($newOld),
  );
  variable_set($var1, serialize($saveArr));
  variable_set($var2, serialize($saveArr));
}


/* SECTION HANDLERS - code that translates old values to new
 * ///////////////// HANDLERS ///////////////////////
 */
function _fin_migrate_handler_address($dstFldName, $inArr, $inData, &$wrapper, $termMap) {
  $countries = array(
      '173'=>'AU',
      '158'=>'AT',
      '1870875315'=>'BS',
      '555'=>'BH',
      '165'=>'BE',
      '1870875319'=>'BM',
      '1870875300'=>'BA',
      '1870875296'=>'BW',
      '130'=>'BR',
      '1870875320'=>'BN',
      '1870875308'=>'BG',
      '127'=>'CA',
      '1870875318'=>'KY',
      '1870875321'=>'GB',
      '133'=>'CL',
      '134'=>'CN',
      '135'=>'CO',
      '138'=>'CR',
      '1870875299'=>'HR',
      '141'=>'CU',
      '8'=>'CY',
      '143'=>'CZ',
      '144'=>'DK',
      '210'=>'FI',
      '211'=>'FR',
      '214'=>'DD',
      '221'=>'GR',
      '185'=>'GU',
      '187'=>'HU',
      '182'=>'IS',
      '208'=>'IN',
      '183'=>'ID',
      '186'=>'IR',
      '174'=>'IL',
      '188'=>'IT',
      '1870875305'=>'JM',
      '191'=>'JP',
      '192'=>'JO',
      '1870875294'=>'KZ',
      '1870875295'=>'KE',
      '1870875297'=>'KW',
      '1870875316'=>'LI',
      '37'=>'LT',
      '38'=>'LU',
      '60'=>'MY',
      '1870875327'=>'MT',
      '1870875310'=>'MU',
      '44'=>'MX',
      '56'=>'MC',
      '1870875312'=>'MZ',
      '19'=>'NL',
      '14'=>'NZ',
      '1870875309'=>'NI',
      '1870875325'=>'KP',
      '1870875324'=>'MP',
      '9'=>'NO',
      '21'=>'PA',
      '1870875306'=>'PG',
      '1870875311'=>'PE',
      '32'=>'PH',
      '26'=>'PL',
      '18'=>'PT',
      '27'=>'PR',
      '1870875298'=>'RO',
      '1870875301'=>'RU',
      '1870875322'=>'SA',
      '63'=>'SG',
      '101'=>'ZA',
      '118'=>'KR',
      '103'=>'SP',
      '112'=>'SE',
      '113'=>'CH',
      '116'=>'TW',
      '1870875302'=>'TZ',
      '75'=>'TH',
      '67'=>'TR',
      '71'=>'UK',
      '61'=>'US',
      '1870875313'=>'AE',
      '1870875293'=>'XX',
      '55555'=>'VE',
    );  
  
    $states = array(
      '356'=>'AL',
      '357'=>'AK',
      '358'=>'AZ',
      '359'=>'AR',
      '360'=>'CA',
      '361'=>'CO',
      '362'=>'CT',
      '363'=>'DE',
      '364'=>'SD',
      '365'=>'FL',
      '366'=>'GA',
      '367'=>'HI',
      '368'=>'ID',
      '369'=>'IL',
      '370'=>'IN',
      '371'=>'IA',
      '372'=>'KS',
      '373'=>'KY',
      '374'=>'LA',
      '375'=>'ME',
      '376'=>'MD',
      '377'=>'MA',
      '378'=>'MI',
      '379'=>'MN',
      '380'=>'MS',
      '381'=>'MO',
      '382'=>'MT',
      '383'=>'NE',
      '384'=>'NV',
      '385'=>'NH',
      '386'=>'NJ',
      '387'=>'NY',
      '388'=>'NC',
      '389'=>'ND',
      '390'=>'OH',
      '391'=>'OK',
      '392'=>'OR',
      '393'=>'PA',
      '394'=>'RI',
      '395'=>'SC',
      '396'=>'TX',
      '397'=>'UT',
      '398'=>'VA',
      '399'=>'WA',
      '400'=>'WV',
      '401'=>'WI',
      '402'=>'WY',
      '403'=>'NM',
      '404'=>'TN',
      '405'=>'VT',
      '486'=>'ONT',
      '487'=>'ALB',
      '488'=>'NB',
      '489'=>'PEI',
      '490'=>'SA',
      '491'=>'NS',
      '492'=>'QE',
      '493'=>'BC',
      '494'=>'NL',
      '1561'=>'DC',
      '956955814'=>'PR',
      '956955815'=>'MB',
  );  

  $addrArr = array();
  $fields = $inArr['fields'];
  foreach ($fields as $handler => $sets) {
    foreach ($sets as $dstFld => $params) {
      $fldName = $params['fldname'];
      if (is_array($fldName)) {
        $val = '';
        $vals = array();
        foreach ($fldName as $fld) {
          $vals[] = $inData->$fld;
        }
        if ($vals) {
          $val = implode(", ", $vals);
        }
      }
      else {
        $val = $inData->$fldName;
      }
      switch ($handler) {
        case 'phone':
          str_replace('ext.','x',$val);
          str_replace('ext','x',$val);
          str_replace('EXT.','x',$val);
          str_replace('EXT','x',$val);
          $pieces = explode("x", $val);
          $val2 = $val; //for debugging purposes
          $val = $pieces[0];
          if (isset($pieces[1])) {
            $addrArr['phone_number_extension'] = $pieces[1];
          }
        break;
        case 'lu2state':
          if ($val) {
            $val = $states[$val];
          } else {
            $val = '';
          }
        break;
        case 'lu2country':
          if ($val) {
            $val = $countries[$val];
          } else {
            $val = '';
          }
        break;
      }
      $val = trim($val);

      $addrArr[$dstFld] = $val;
    }
  }
  //$wrapper->$destFldName = $addrArr;
  return $addrArr;
}
 
function _fin_migrate_handler_paragraph($bundle, $hostFldName, $sets, $inData, &$wrapper, &$entity, $termMap, $primeKeyFldName='', $primeKey=0, $deferSave=FALSE) {
  $oldNew_col = array();
  $newOld_col = array();
  $variable = 'fin-migrate-oldnew-paragraphs';
  $oldNews = _fin_migrate_get_best_map($variable);
  if ($oldNews) {
    $oldNew_col = unserialize($oldNews['oldnew']);
    $newOld_col = unserialize($oldNews['newold']);
  }
  $fields = $sets['fields'];
  $params = $sets['params'];
  
  $pKeyName = $primeKeyFldName;
  $pKey = 0;
  if ($pKeyName) {
      $pKey = $inData->$pKeyName;    
  }

  if ( isset($params['oldtable']) ) {
    $srcTable = $params['oldtable'];
    $pKeyName = $primeKeyFldName;
    if (!isset($primeKeyFldName)) {
      $primeKeyFldName = $params['oldkeyfldname'];
      $primeKey = $inData->$primeKeyFldName;
      $pKeyName = $primeKeyFldName;
    }
    if (isset($params['oldkeyfldname'])) {
      $pKeyName = $params['oldkeyfldname'];
    }
    
    $pKey = $inData->$primeKeyFldName;
    
    if (isset($params['key-alias'])) {
      $pKeyName = $params['key-alias'];
    }
    $rowKeyFldName = $pKeyName;
    if (isset($params['rowkeyfldname'])) {
      $rowKeyFldName = $params['rowkeyfldname'];
    }

    $res = _fin_migrate_get_best_additional_table_data($srcTable, $pKeyName, $pKey);
$message = "Fldname: ".$hostFldName." Sets contain: ".print_r($sets,true);
watchdog('FIN_MIGRATE_COLLECTION', $message, array(), WATCHDOG_INFO);
 
////debugBreak();

    if ($res && isset($params['onerow'])) {
      $key = $params['onerowkeyname'];
      $fld = $params['onerowfldname'];
      $rws = $res;
      $res = '';
      $rwfld = array();
      foreach ($rws as $rw) {
        $vl = $rw->{$fld};
        $ky = (string) $rw->{$key};
        $rwfld[$ky]=$vl; 
      }
      $res[] = (object) $rwfld;
    }
  } else {
    if (count($inData)>1) {
      $res = $inData;
    } else {
      $res = array($inData);
    }
  }
  if ($res) {
    //$wrappers = array();
    $entities = array();
    foreach ($res as $rw) {
      $newParagraph = new ParagraphsItemEntity(array('field_name' => $hostFldName, 'bundle' => $bundle));
      $newParagraph->is_new = TRUE;
      $newParagraph->setHostEntity('node', $entity);
      $newParagraph->save();

debugBreak();

      $flds = $sets['fields'];
      _fin_migrate_process_fields($flds, $rw, $newParagraph, $newParagraph, $termMap, $pKeyName, $pKey, "collection");

      $newParagraph->save();
      $wrappers[] = $p_wrapper;
      $newParagraph->save();
    }
  }
  
  if (!$deferSave) {
    // We save everything at once, a cheap form of atomicity
    foreach ($wrappers as $p_wrapper) {
      $p_wrapper->save();
    }
    $wrapper->save();
  }
  return $wrappers;
}

function _fin_migrate_handler_collection($hostFldName, $sets, $inData, &$wrapper, &$entity, $termMap, $primeKeyFldName='', $primeKey=0) {

  $oldNew_col = array();
  $newOld_col = array();
  $variable = 'fin-migrate-oldnew-collection';
  $oldNews = _fin_migrate_get_best_map($variable);
  if ($oldNews) {
    $oldNew_col = unserialize($oldNews['oldnew']);
    $newOld_col = unserialize($oldNews['newold']);
  }
  $fields = $sets['fields'];
  $params = $sets['params'];
  
  $pKeyName = $primeKeyFldName;
  $pKey = 0;
  if ($pKeyName) {
      $pKey = $inData->$pKeyName;    
  }

  if ( isset($params['oldtable']) ) {
    $srcTable = $params['oldtable'];
    $pKeyName = $primeKeyFldName;
    if (!isset($primeKeyFldName)) {
      $primeKeyFldName = $params['oldkeyfldname'];
      $primeKey = $inData->$primeKeyFldName;
      $pKeyName = $primeKeyFldName;
    }
    if (isset($params['oldkeyfldname'])) {
      $pKeyName = $params['oldkeyfldname'];
    }
    
    $pKey = $inData->$primeKeyFldName;
    
    if (isset($params['key-alias'])) {
      $pKeyName = $params['key-alias'];
    }
    $rowKeyFldName = $pKeyName;
    if (isset($params['rowkeyfldname'])) {
      $rowKeyFldName = $params['rowkeyfldname'];
    }

    $res = _fin_migrate_get_best_additional_table_data($srcTable, $pKeyName, $pKey);
$message = "Fldname: ".$hostFldName." Sets contain: ".print_r($sets,true);
watchdog('FIN_MIGRATE_COLLECTION', $message, array(), WATCHDOG_INFO);
  
    if ($res && isset($params['onerow'])) {
      $key = $params['onerowkeyname'];
      $fld = $params['onerowfldname'];
      $rws = $res;
      $res = '';
      $rwfld = array();
      foreach ($rws as $rw) {
        $vl = $rw->{$fld};
        $ky = (string) $rw->{$key};
        $rwfld[$ky]=$vl; 
      }
      $res[] = (object) $rwfld;
    }
  } else {
    $res = array($inData);
  }
  if ($res) {
    $wrappers = array();
    foreach ($res as $rw) {
      $newCollection = entity_create('field_collection_item', array('field_name' => $hostFldName));

      $newCollection->setHostEntity('node', $entity);
      $fc_wrapper = entity_metadata_wrapper('field_collection_item', $newCollection);

      $flds = $sets['fields'];
      _fin_migrate_process_fields($flds, $rw, $fc_wrapper, $entity, $termMap, $pKeyName, $pKey, "collection");

      $wrapper[] = $fc_wrapper;
    }
  }
  
  // We save everything at once, a cheap form of atomicity
  foreach ($wrapper as $fc_wrapper) {
    $fc_wrapper->save();
  }
  $wrapper->save();
}

function _fin_migrate_process_fields($fields, $inData, &$wrapper, &$entity, $termMap,$primeKeyFldName='', $primeKey=0, $collection='') {
  foreach ($fields as $handler => $sets) {
    foreach ($sets as $dstFldName => $params) {
      _fin_migrate_process_field($handler, $dstFldName, $params, $inData, $wrapper, $entity, $termMap, $primeKeyFldName, $primeKey, $collection);
    }
  }
}

function _fin_migrate_process_field($handler, $dstFldName, $params, $inData, &$wrapper, &$entity, $termMap, $primeKeyFldName='', $primeKey='', $collection='') {

  $statusArr = array(
    'Active' => 340,
    'Inactive' => 341,
  );    

  $val = '';
  if ( isset($params['fldname']) ) {
    if ( !empty($params['fldname']) ) {
      $fldName = $params['fldname'];
      $val = $inData->$fldName;
    }
  }
  else if ( isset($params['value']) ) {
    $val = $params['value'];
  }

  //$dstVal = $wrapper->$dstFldName;
  //if (!empty($val)) {
//  if (!empty($val) || !empty($dstval)) {
  if (1) {
    $action = $handler;

$message = "Action: ".$action." Field: ".$dstFldName." Val: ".print_r($val,true);
watchdog('PROCESS FIELD', $message, array(), WATCHDOG_INFO);

    switch ($action) {
      case 'node-title':
        $wrapper->title = $val;
      break;
      case 'node-body':
        if (!$val) {
          $val = " ";
        }
        $wrapper->body->value = $val;
        $wrapper->body->summary = $val;
        $wrapper->body->format = 'filtered_html';
      break;
      case 'node-date2date':
        $out = strtotime($val);
        $wrapper->$dstFldName = $out;
      break;
      case 'node-inactive-status':
        $out = 1;
        if ((int) $val) {
          $out = 0;
        }
        $wrapper->status = $out;
      break;
      case 'node-value-status':
        $wrapper->status = $val;
      break;
      case 'consolidate':
        // use when you have an address1, address2, address3 to map to 2 fields
        $out = _fin_migrate_handle_consolidate($nodeMapArr);
        $wrapper->$dstFldName = $out;
      break;
      case 'name2uid':
        $account = user_load_by_name($val);
        $out = $account->uid;
        $wrapper->$fldName = intval($out);
      break;
      case 'value' :
        $out = $params['value'];
        $wrapper->$fldName = $out;
      break;
      case 'value2term':
        if (isset($params['handler'])) {
          $handl = $params['handler'];
          switch ($handl) {
            case 'negate':
              $raw = (int) $val;
              if ($raw) {
                $val = 0;
              } else {
                $val = 1;
              }
             break;
          }
        }
        $vid = $params['voc'];
        $values = $params['values'];
        $name = $values[$val];
        $term = _fin_migrate_get_tid_by_name($name, $vid);
        $term2 = taxonomy_get_term_by_name($name, $vid); 
        if ($term) {
          $wrapper->$dstFldName = intval($term);
        } 
      break;
      case 'tid2term':
        if (isset($params['handler'])) {
          $handl = $params['handler'];
          switch ($handl) {
            case 'negate':
              $raw = (int) $val;
              if ($raw) {
                $val = 0;
              } else {
                $val = 1;
              }
             break;
          }
        }
        $out = $val;
        $wrapper->$dstFldName = intval($out);
      break;
      case 'lu2currency':
        $fallback = array(
          'US Dollar' => 'United States Dollar',
        );
        if ($val) {
          if (isset($termMap[$fldName]['oldterms'][$val])) {
            $name = $termMap[$fldName]['oldterms'][$val];
            $tid = 0;
            if (isset($termMap[$fldName]['newterms'][$name])) {
              $tid = $termMap[$fldName]['newterms'][$name];
            }
            // because names were altered, above is hit-and-miss. This is a fallback
            if (!$tid) {
              if (isset($fallback[$name])) {
                $name = $fallback[$name];
                $tid = $termMap[$fldName]['newterms'][$name];
              }
            }
            if ($tid) {
              $wrapper->$dstFldName = $tid;
            } else {
              $message = 'Old Term: ".$name." (".$val.") Field: ".$dstFldName." Unmatched';
              watchdog('FIN_MIGRATE_lu2term', $message, array(), WATCHDOG_INFO);
            }
          }
        }
      break;
      case 'lu2term':
        $fallback = array(
          'US Dollar' => 'United States Dollar',
        );
        if ($val) {
          if (isset($termMap[$fldName]['oldterms'][$val])) {
            $tid = 0;
            $term = $termMap[$fldName]['oldterms'][$val];
            // because names were altered, above is hit-and-miss. This is a fallback
            if (isset($termMap[$fldName]['newterms'][$term])) {
              $tid = $termMap[$fldName]['newterms'][$term];
            }              
            if (!$tid) {
              $name = $fallback[$term];
              if (isset($termMap[$fldName]['newterms'][$name])) {
                $tid = $termMap[$fldName]['newterms'][$name];
              }
            }
            if ($tid) {
              //$entity->$dstFldName['und'][0]['tid'] = $tid;
              //entity_save($entity);
              $wrapper->$dstFldName = $tid;
            }
          }
        }
      break;
      case 'term2term':
        $fallback = array(
          'US Dollar' => 'United States Dollar',
        );
        if ($val) {
          if (isset($termMap[$dstFldName]['oldterms'][$val])) {
            $tid = 0;
            $term = $val;
            //$term = $termMap[$fldName]['oldterms'][$val];
            // because names were altered, above is hit-and-miss. This is a fallback
            if (isset($termMap[$fldName]['newterms'][$term])) {
              $tid = $termMap[$fldName]['newterms'][$term];
            }              
            if (!$tid) {
              $name = $fallback[$term];
              if (isset($termMap[$fldName]['newterms'][$name])) {
                $tid = $termMap[$fldName]['newterms'][$name];
              }
            }
            if ($tid) {
              $wrapper->$dstFldName = $tid;
            }
          }
        }
      break;

/////////////////////
      case 'lu2state':
        $out = $states[$val];
        $wrapper->$dstFldName = intval($out);
      break;
      case 'lu2country':
        $out = $countries[$val];
        $wrapper->$dstFldName = intval($out);
      break;
      case 'majorminor':
        $majorId = $inData->MajorStyleID;
        if ($majorId) {
          $majorName = $termMap['MajorStyleID']['oldterms'][$majorId];
          $majorTid = $termMap['MajorStyleID']['newterms'][$majorName];

          $minorId = $inData->MinorStyleID;
          if ($minorId) {
            $minorName = $termMap['MinorStyleID']['oldterms'][$minorId];
            $minorTid = $termMap['MinorStyleID']['newterms'][$minorName];
            if ($minorTid && $majorTid) {          
              $out = array(
                array('target_id' => $majorTid),
                array('target_id' => $minorTid),
              );
              $wrapper->$dstFldName = $out;
            } else {
              $message = t('PROBLEM: Major: %majorname | ID: %majorid | Tid: %majortid || Minor: %minorname | ID: %minorid | Tid: %majorid', array(
                 '%majorname' => $majorName,
                 '%majorid' => $majorId,
                 '%majortid' => $majorTid,
                 '%minorname' => $minorName,
                 '%minorid' => $minorId,
                 '%minortid' => $minorTid
                )
              );
            }
          }
        }
      break;    
      case 'majorminorxxx':
        $obj = taxonomy_vocabulary_machine_name_load('major_minor_styles');
        $vid = $obj->vid;
        $fields = $params['fields'];
        $set = array();
        foreach ($fields as $fld) {
          $name = $termMap[$fld]['oldterms'][$val];
          $term = taxonomy_get_term_by_name($name, $vid);
          $tid = $term->term_id;
          $level = count(taxonomy_get_parents_all($tid));
          $set[$tid] = $level;
        }
        if ($set) {
          $winner = 0;
          $topTid = 0;
          foreach ($set as $tid=>$level) {
            if ($level>$winner) {
              $winner = $level;
              $topTid = $tid;
            }
          }
          if ($topTid) {
            $wrapper->$dsFldName = $topTid;
          }
        }
      break;    
      case 'array2term':
        $oldTerm = $params['values'][$val];
        $term = $termMap[$fldName]['oldterm'][$oldTerm];
        $out = $termMap[$fldName]['newterm'][$term];
        $wrapper->$dstFldName = intval($out);
      break;
      case 'http2link':
        $url = strtolower(trim($val));
        if (!isset($params['title'])) {
          $title = $url;
        } else {
          $title = $params['title'];
        }
        if ($url) {
          $parsed = parse_url($url);
          if (empty($parsed['scheme'])) {
            $url = 'http://' . ltrim($url, '/');
          }               
          if (!$url) {
            $wrapper->$dstFldName->set(array(
              'title' => '',
              'url' => '',
            ));
          } else {
            $wrapper->$dstFldName->set(array(
              'title' => $title,
              'url' => $url,
            ));

            //$wrapper->$dstFldName->url = $out;
            //$wrapper->$dstFldName->title = $url;
            //$wrapper->$dstFldName->attributes = array('title'=>'Go Here', 'target'=>'_new');
          }
        }
      break;
      case 'mixed2link':
        $url = strtolower(trim($val));
        if (!isset($params['title'])) {
          $title = $url;
        } else {
          $title = $params['title'];
        }
        if ($url) {
          $parsed = parse_url($url);
          if ($parsed) {
            $message = $dstFldName ." may have URL. Data: ".print_r($parsed,true);
            watchdog('FIN_MIGRATE_URL_CHECK', $message, array(), WATCHDOG_INFO);

            if (empty($parsed['scheme'])) {
              $url = 'http://' . ltrim($url, '/');
            }               
            if (!$url) {
              $wrapper->$dstFldName->set(array(
                'title' => '',
                'url' => '',
              ));
            } else {
              $wrapper->$dstFldName->set(array(
                'title' => $title,
                'url' => $out,
              ));
            }
          }
        }
      break;
      case 'text2email':
        if ($val) {
          $out = trim($val);
          //$entity->$dstFldName['und'][0]['email'] = $val;
          //entity_save($entity);
          $wrapper->$dstFldName = $val;
        }
      break;
      case 'foia2notes':
        if (isset($params['names'])) {
          $names = $params['names'];
          $notes = array();
          foreach ($names as $fld) {
              $notes[] = $inData->{$fld};
          }
          if ($notes) {
            $out = implode(" | ", $notes);
            if ($out) {
              $wrapper->{$dstFldName} = $out;
            }
          }
        }
      break;
      case 'html2history':
        if ($val) {
          $out = array();
          $items = explode('<br/>', $val);
          foreach ($items as $item) {
            $date = strtotime(substr($item, 0, 10));
            $wrapper->$dstFldName = $out;
          }
        }
      break;
      case 'picture':
        $imgpath = base_path() . 'migration/' . $val;
        $filename = basename($imgpath);
        $title = $wrapper->title_field;
        if (file_exists($imgpath)) {
          $file = (object) array(
            'uri' => $imgpath,
            'filemime' => file_get_mimetype($imgpath),
            'status' => 1,
            'title' => $title,
          );
          $drupalfile = file_copy($file, 'private://pictures/');
          $wrapper->dsfFldName = (array) $drupalfile;
        }
      break;
      case 'address':
        $out = _fin_migrate_handler_address($dstFldName, $params, $inData, $wrapper, $termMap);
        //$wrapper->$dstFldName = $out;
        //$entity->$dstFldName['und'][0] = $out;
        //entity_save($entity);
        foreach ($out as $fldName => $val) {
          $wrapper->$dstFldName->$fldName = trim($val);
        }
      break;
      case 'reference':
        $refArray = array(
          'ConsultantOfficeID'=>'office',
          'ConsultantFirmID' => 'consultant firm',
          'ConsultantContactID' => 'consultant contact',
          'ManagerContactID' => 'manager contact',
          'ManagerFirmID' => 'manager firm',
          'FundContactID' => 'plan contact',
          'FundID' => 'plan',
          'MandateID' => 'mandate'
        );

        $oldKeyFldName = $params['fldname'];
        $pseudonym = $refArray[$oldKeyFldName];
        $oldNews = _fin_migrate_get_best_map();
        $ref = unserialize($oldNews['oldnew']);
        $new = $ref[$pseudonym][$val];
        if ($new) {
          //$entity->$dstFldName['und'][0]['target_id'] = $new;
          //entity_save($entity);
          $wrapper->$dstFldName = $new;
        }

/* One field at a time, like the other handlers
        $flds = $params['fields'];
        if ($flds) {
          foreach ($flds as $dstFld => $fld) {
            $oldKeyFldName = $fld['fldname'];
            $pseudonym = $refArray[$oldKeyFldName];
            $vl = $inData->$oldKeyFldName;
            $oldNews = _fin_migrate_get_best_map();
            $ref = unserialize($oldNews['oldnew']);
            $new = $ref[$pseudonym][$vl];
            if ($new) {
              $wrapper->$dstFld = $new;
            }
          }
        }
*/
      break;
      case 'inactive2term':
        $name = 'Active';
        // if TRUE, inactive. Booleans should be positive, not negative, this is why 
        // we have special handling here
        if ($val) {
          $name = 'Inactive';
        }
        //$vid = intval($params['voc']);
        //$term = _fin_migrate_get_tid_by_name($name, $vid);
        //$out = $term->tid;
        $out = $statusArr[$name];
        $wrapper->$dstFldName = $out;
      break;
      case 'status2term':
        $name = 'Active';
        // if TRUE, inactive. Booleans should be positive, not negative, this is why 
        // we have special handling here
        if (!$val) {
          $name = 'Inactive';
        }
//$out = $termMap[$fldName]['newterm'][$term];
        //$vid = intval($params['voc']);
        //$term = _fin_migrate_get_tid_by_name($name, $vid);
        //$out = $term->tid;
        $out = $statusArr[$name];
        $wrapper->$dstFldName = intval($out);
      break;
      case 'date2timestamp':
        if($val && $val<>'0000-00-00 00:00:00') {
          $out = strtotime($val);
          $wrapper->$dstFldName->set($out);
        }
      break;
      case 'date2date':
        $out1 = strtotime($val);
        $out2 = date('Y-m-d H:i:s', $out1);
        $out = $out2;
        $wrapper->$dstFldName->set(array(
          'value' => $out,
          'value2' => $out,
        ));
      break;
/*
case 'comma-delimited-delta-default':
break;
case 'field_manager_firm_er':
break;

*/
      case 'comma-delimited-delta-default':
        $delta = $inData->fin-delta;
        $arr = explode(',',$arr);
        $out = $arr[$delta];
        $wrapper->$dstFldName = $out;
      break;
      case 'comma-delimited-er':
        $delta = $inData['fin-delta'];
        $arr = explode(',',$arr);
        $old = $arr[$delta];
        $oldNew = _fin_migrate_get_best_map();
        $out = $oldnew['map'][$oldKeyName]['oldnew'][$old];
        $wrapper->$dstFldName = $out;
      break;
      case 'employmentdate':
        if ($val) {
          $format = 'Y-m-d G:i:s';          
          $date1 = $val;
          $fdate1 = date($format, $date1);
          $date2 = $inData->end;
          if (empty($date2)) {
            $fdate2 = NULL;
          } else {
            $fdate2 = date($format, $date2);
          }
          $arr = array(
            'value' => $fdate1,
              'value2' => $fdate2);
          //$entity->{$dstFldName}['und'][0] = $arr;
          //entity_save($entity);
  
          //$wrapper->{$dstFldName}->set(array(
          //  'value' => $date1,
          //  'value2' => $date2
          //));
        }
      break;
    
////////////////////
      case 'collection':
        $newInData[] = $inData;
        if (isset($params['multiplier'])) {
          $multi = $params['multiplier'];
          $handlr = $multi['handler'];
          $parms = $multi['params'];
          $tbl = $multi['oldtable'];
          $kyfld = $multi['oldkeyfldname'];
          $ky = $inData[$kyfld];
          $fld = $multi['oldfldname'];
          $multiArr = _fin_migrate_get_multiplier($handlr, $tbl, $kyfld, $ky, $fld);
          $newInData = array();
          foreach ($multiArr as $multiFld => $multiVal) {
            $inData->$multiFld = $multiVal;
            $newInData[] = $inData;
          }
        }
        $collections = $params['sets'];
        foreach ($newInData as $inData) {
          foreach ($collections as $collection) {
            _fin_migrate_handler_collection($dstFldName, $collection, $inData, $wrapper, $entity, $termMap, $primeKeyFldName, $primeKey);
          }
        }
      break;
      case 'paragraph':          
        //$paragraphs = $map['paragraph'];
        $bundle = $params['param']['bundle'];
        $newInData[] = $inData;
        if (isset($params['multiplier'])) {
          $multi = $params['multiplier'];
          $handlr = $multi['handler'];
          $parms = $multi['params'];
          $tbl = $multi['oldtable'];
          $kyfld = $multi['oldkeyfldname'];
          $ky = $inData[$kyfld];
          $fld = $multi['oldfldname'];
          $multiArr = _fin_migrate_get_multiplier($handlr, $tbl, $kyfld, $ky, $fld);
          $newInData = array();
          foreach ($multiArr as $multiFld => $multiVal) {
            $inData->$multiFld = $multiVal;
            $newInData[] = $inData;
          }
        }
        $paragraphs = $params['sets'];
        foreach ($newInData as $inData) {
          foreach ($paragraphs as $paragraph) {
            _fin_migrate_handler_paragraph($bundle, $dstFldName, $paragraph, $inData, $wrapper, $entity, $termMap, $primeKeyFldName, $primeKey);
          }
        }
      break;
      case 'note-comment-to-note':
        $deltas = count($wrapper->$dstFldName);
        $sources = array(
          '242' => 'mccue@fin-news.com',
          '260' => 'gar guymoso@Yahoo.com',
        );
        $sourceid = $inData->SourceID;
        $sql = 'select uid from {users} where mail="'.$sources[$sourceid].'"';
        db_set_active();
        $res = db_query($sql);
        foreach ($res as $item) {
          $uid = $item->uid;
        }
        $sourcedate = $inData->SourceDate;
        if (stripos($sourcedate, 'ear)-(Month-Day')) {
          $date = time(0);
        } else {
          $date = strtotime($sourcedate);
        }
        $comment = $inData->Comments;
        $wrapper->$dstFldName[$delta]->field_mandate_note_author = $uid;
        $wrapper->$dstFldName[$delta]->field_note_author = $uid;
        $wrapper->$dstFldName[$delta]->field_date = $date;
        $wrapper->$dstFldName[$delta]->field_mandate_note = $comment;
      break;
      case 'note-history-to-note':
        $sourceid = $inData->SourceID;
        $sql = 'select uid from {users} where mail="'.$sources[$sourceid].'"';
        db_set_active();
        $res = db_query($sql);
        foreach ($res as $item) {
          $uid = $item->uid;
        }
        $history = $inData->History;
        $split_pattern = "/^|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])|[0-9]{4}-(0[1-9]$/";
        $raw = preg_split($pattern, $history, NULL, PREG_SPLIT_DELIM_CAPTURE);
        $count = count($raw);
        $raw[] = '';
        $content = array();
        for ($x=0; $x<$count; $x+2) {
          $date = $raw[$x];
          $entry = $raw[$x+1];
          if ($date) {
            $time = strtotime($date);
            $content[$time] = $entry;
          }
        }
        if ($content) {
          $set = array();
          $delta = count($wrapper->$dstFldName);
          foreach ($content as $time => $entry) {
            $wrapper->$dstFldName[$delta]->field_date = $time;
            $wrapper->$dstFldName[$delta]->field_note_author = $uid;
            $wrapper->$dstFldName[$delta]->field_mandate_note_author = $uid;
            $wrapper->$dstFldName[$delta]->field_mandate_note = $entry;
            $delta++;
          }
        }
      break;
      case 'note-comments-to-note':        
        $uid = 1;
        $delta = count($wrapper->$dstFldName);
        foreach ($inData as $row) {
          $entry = $row->Comment;
          $date = $row->Created;
          $wrapper->$dstFldName[$delta]->field_date = $time;
          $wrapper->$dstFldName[$delta]->field_note_author = $uid;
          $wrapper->$dstFldName[$delta]->field_mandate_note_author = $uid;
          $wrapper->$dstFldName[$delta]->field_mandate_note = $entry;
          $delta++;
        }
      breakl;
      case 'disabled':
      break;
      case 'mom':
        $mom = $inData->ManagerFirmID;
        $sql = 'SELECT ManagerFirmID FROM tblmommanagers WHERE MoMID='.$mom;
        db_set_active('legacy');
        $res = db_query($sql);
        db_set_active();
        if ($res->rowCount()>0) {
debugBreak();
          $oldNews = _fin_migrate_get_best_map();
          $ref = unserialize($oldNews['oldnew']);
          $out = array();
          foreach ($res as $item) {
            $oldid = $item->ManagerFirmID;
            $newid = _fin_migrate_gotIdgetNid($id, $pseudonym, $newOld);
            $out[]['target_id'] = $item->ManagerFirmID;
          }
          $wrapper->{$dstFldName} = $out;
          $wrapper->field_manager_of_managers = 1;
        }
      break;
      case 'onwatch':
case 'reference':
        $refArray = array(
          'ConsultantOfficeID'=>'office',
          'ConsultantFirmID' => 'consultant firm',
          'ConsultantContactID' => 'consultant contact',
          'ManagerContactID' => 'manager contact',
          'ManagerFirmID' => 'manager firm',
          'FundContactID' => 'plan contact',
          'FundID' => 'plan',
          'MandateID' => 'mandate'
        );

        // val is a single oldid or comma delimited id
        $oldids = explode("," , $val);
        $oldKeyFldName = $params['oldkeyfldname'];
        $pseudonym = $refArray[$oldKeyFldName];
        $oldNews = _fin_migrate_get_best_map();
        $ref = unserialize($oldNews['oldnew']);
        $out = array();
        foreach ($oldids as $oldid) {
          $newid = $ref[$pseudonym][$oldid];
          $out[]['target_id'] = $item->{$oldKeyFldName};
        }
        if (!empty($out)) {
          $wrapper->{$dstFldName} = $out;
        }
      break;
      case 'asset-allocation':
        //          '7' => 'field_aa_international_fixed_income',
        $allocationFieldMap = array(
          '2' => 'field_aa_domestic_equities',
          '3' => 'field_aa_domestic_fixed_income',
          '4' => 'field_aa_alternative_strategies',
          '5' => 'field_aa_hedge_fund_strategies',
          '6' => 'field_aa_international_equities',
          '7' => 'field_aa_intl_fixed_income',
          '8' => 'field_aa_mutual_fund',
          '10' => 'field_aa_private_equity',
          '11' => 'field_aa_real_estate',
          '12' => 'field_aa_real_assets',
          '13' => 'field_aa_cash_other',
          '14' => 'field_aa_balanced',
          '15' => 'field_aa_global_equities',
          '16' => 'field_aa_absolute_return',
          '18' => 'field_aa_global_fixed_income',
          '19' => 'field_aa_credit_opportunities',
          '20' => 'field_aa_real_return',
          '21' => 'field_aa_multi_asset',
          '22' => 'field_aa_emerging_markets_equity',
          '23' => 'field_aa_risk_parity',
          '24' => 'field_aa_canadian_equities',
        );
        $messageArr = array();
        foreach ($inData as $ky => $vl) {
          $fldName = $allocationFieldMap[$ky];
          $wrapper->{$fldName} = $vl;
          $messageArr[] = "Fieldname: ".$fldName." = ".$vl."%";   
        }
        $message = "For ".$wrapper->label()." assign ".print_r($messageArr,true);
        watchdog("FIN_MIGRATE Asset Allocation", $message, array(), WATCHDOG_INFO);

        //$keyFldName = $params['keyfldname'];
        //$fid = $inData->$keyFldName;
        //$dstFldName = $allocationFieldMap[$fid];
        //$out = $inData->percentage;
        //if ($out) {
          //$wrapper->$dstFldName = $out;
        //}

//bugBrrrk();

      break;
      
      case 'asset-allocationxxx':
        $allocationFieldMap = array(
          '2' => 'field_aa_domestic_equities',
          '3' => 'field_aa_domestic_fixed_income',
          '4' => 'field_aa_alternative_strategies',
          '5' => 'field_aa_hedge_fund_strategies',
          '6' => 'field_aa_international_equities',
          '7' => 'field_aa_international_fixed_income',
          '8' => 'field_aa_mutual_fund',
          '10' => 'field_aa_private_equity',
          '11' => 'field_aa_real_estate',
          '12' => 'field_aa_real_assets',
          '13' => 'field_aa_cash_other',
          '14' => 'field_aa_balanced',
          '15' => 'field_aa_global_equities',
          '16' => 'field_aa_absolute_return',
          '18' => 'field_aa_global_fixed_income',
          '19' => 'field_aa_credit_opportunities',
          '20' => 'field_aa_real_return',
          '21' => 'field_aa_multi_asset',
          '22' => 'field_aa_emerging_markets_equity',
          '23' => 'field_aa_risk_parity',
          '24' => 'fi_aa_canadian_equities',
        );
        $keyFldName = $params['keyfldname'];
        $dstFldName = $allocationFieldMap[$keyFldName];
        $wrapper->$dstFldName = $val;
      break;
      default:
        $out = $val;
        if ($out) {
          //$entity->$dstFldName['und'][0] = $out;
          //entity_save($entity);
          $wrapper->$dstFldName = $out;
        }
      break;
    }
    //return $out;
    return TRUE;
  }
}

function _fin_migrate_get_multiplier($handler, $oldTable, $oldKeyFldName, $oldKey, $returnFldName) {
  switch($handler) {
    case 'external-table':
      $rs = _fin_migrate_get_best_additional_table_data($oldTable, $oldKeyFldName, $oldKey);
      $out = array();
      foreach ($rs as $r) {
        $out[] = array('fldname'=>$returnFldName, 'value'=>$r->$returnFldName);
      }
      break;
    }
    if ($out) {
      return $out;
    }
}

function _fin_migrate_get_tid_by_name($name, $vid) {
  db_set_active();
  $sql = "select tid from {taxonomy_term_data} where vid=".$vid." and name='".$name."' limit 1";
  $res = db_query($sql);
  foreach ($res as $item) {
    $tid = $item->tid;
  }
  return $tid;
}

function _fin_migrate_handler_system($inArr, $inData, &$wrapper, &$entity, $termMap) {
  $fields = $inArr['fields'];
  // currently we only have fields section to process
  _fin_migrate_process_fields($fields, $inData, $wrapper, $entity, $termMap);
}

/*
 * Helper function to grab data from secondary tables as needed
 * Features:
 *  - Grabs entire secondary tables from old database
 *  - Caches tables for repeated use, especially key tables
 *    Returns only rows related to current parent table movement
 *
 * @parameters 
 *  $srcTable - Secondary table to read or pull from cache
 *  $primeKeyFldName - Name of parent table prime, or this table foreign key
 *    We use this for indexing the cached array, and for selecting data we need
 *  $primeKey - the actual maching value we are looking for
 * @returns
 *  $res - an array of query resultsets, fetched
 *  
 */
function _fin_migrate_get_best_additional_table_data($srcTable, $primeKeyFldName, $primeKey) {
  $res = array();
  $tabls = unserialize(variable_get('fin-migrate-tabl'));
  if (!isset($tabls[$srcTable])) {
    if (!$tabls[$srcTable]) {
      // we cannot use indata here, we have to selectively read another table
      $sql = "select * from ".$srcTable;
      db_set_active('legacy');
      $res = db_query($sql);
      db_set_active();

      // as is, res is not useful, we need to index it by oldkeys for quick access later
      //$ref = array();
      $ref = '';
      foreach ($res as $rs) {
        $pk = $rs->$primeKeyFldName; 
        $ref[$pk][] = $rs;
      }
            // save table to the database in case we need it later
      $tabls[$srcTable] = $ref;
      variable_set('fin-migrate-tabl', serialize($tabls));
           
      // we still need the rows pretaining to our current parent data
      $resArray = $ref[$primeKey];
    }
  } else {
    $ind = (int) $primeKey;
    $resArray = $tabls[$srcTable][$primeKey];  }   
  return $resArray;
}

/*
 * Wrapper Function to make a common id for nid operation consistent
 */
function _fin_migrate_gotIdgetNid($id, $pseudonym, $oldNew) {
  if (isset($oldNew[$pseudonym][$id]['nid'])) {
    return $nid;
  } else {
    $message = $pseudonym ." |id: ".$id." missing from OldNew: ".print_r($oldNew,true);
    watchdog('FIN_MIGRATE_NID4ID', $message, array(), WATCHDOG_INFO);
  }
}

/*
 * Function to build and add to New Old Tables upon arrival of new batch of
 * Step1 'skeletal' nodes. For performance reasons, step1 does not build 
 * this list, but embeds pseudonym and id into a specially formatted title
 * This is called first thing in Step2.
 *
 * Yes, it could take awhile.
 */
function _fin_migrate_add_step1_nodes_to_oldnew() {
  $refArray = array(
    'consultant firm' => 'tblconsultantfirms',
    'office' => 'tblconsultantfirmoffices',
    'consultant contact' => 'tblconsultantcontacts',
    'manager contact' => 'tblmanagercontacts',
   'manager firm' => 'tblmanagerfirms',
    'plan contact' => 'tblfundcontacts',
    'plan' => 'tblfunds',
    'mandate' => 'tblmandates'
  );

  // if we already have a new old index, we may want to add to it
  $variable = 'fin-migrate-node';
  $oldNew = array();
  $newOld = array();
  $oldNews = _fin_migrate_get_best_map($variable);
  if ($oldNews) {
    $oldNew = unserialize($oldNews['oldnew']);
    $newOld = unserialize($oldNews['newold']);
  }
  
// We also have a Name to Nid table for Contacts to maintain  
  $nameNids = array();
  $nameNids = unserialize(variable_get('fin-migrate-contact-contactnames'));

// Get the new nodes
  $sql = "SELECT nid, title FROM {node} WHERE title LIKE 'migration%' or title LIKE 'contactmigration%' or title like 'mandate-[%'";
  $res = db_query($sql);

  foreach ($res as $item) {
    $nid = $item->nid;
    $title = $item->title;
    $pieces = explode("-", $title);
    $class = $pieces[0];
    if ($class=="Mandate") {
      $pseudonym = 'mandate';
      $id = $pieces[2];
    } else {
      $pieces = explode("|", $title);
////     $pieces = explode("|", $title);
      $class = $pieces[0];
      $table = '';
      if (isset($refArray[$pseudonym])) {
        $table = $refArray[$pseudonym];
      }
      $id = $pieces[2];
    }      
    if (!isset($oldNew[$pseudonym][$id])) {
      $oldNew[$pseudonym][$id]['nid'] = $nid;
    } 
    //New Old is one to many, since contact may serve many ids
    if (!isset($newOld[$pseudonym][$nid][$id])) {
      $newOld[$pseudonym][$nid]['id'][$id] = $id;
    }

    $contactName = '';
    if ($class=="contactmigration") {
        $contactName = $pieces[3];
        $nameNids[$contactName]['nid'] = $nid;
    }
    $sql = "INSERT INTO {fin_migrate} (pseudonym, srcid, nid, contactname) VALUES('%pseudonym', %srcid, %nid, '%contactname')";
    $sql = str_replace('%pseudonym', $pseudonym, $sql);
    $sql = str_replace('%srcid', $id, $sql);
    $sql = str_replace('%nid', $nid, $sql);
    $sql = str_replace('%contactname', $contactName, $sql);

debugBreak();

    db_query($sql);
  }

  $message = "New Old: ".print_r($newOld,true);
  watchdog('FIN_MIGRATE_BATCH_BUILD_NEWOLD', $message, array(), WATCHDOG_INFO);
  $message = "Old New: ".print_r($oldNew,true);
  watchdog('FIN_MIGRATE_BATCH_BUILD_NEWOLD', $message, array(), WATCHDOG_INFO);
  $message = "Name Nids: ".print_r($nameNids,true);
  watchdog('FIN_MIGRATE_BATCH_BUILD_NEWOLD', $message, array(), WATCHDOG_INFO);

// Now that we are done building/updating the Indices, save them
////_fin_migrate_update_map($variable, $oldNew, $newOld);
////variable_set('fin-migrate-contact-contactnames', serialize($nameNids));
}

/*
 * //////////////////// Helper Functions ///////////////////
 */
function fin_migrate_update_map($name, $oldNew, $newOld) {
  $var1 = $name .'1';
  $var2 = $name . '2';
  $saveArr = array(
    'oldnew' => serialize($oldNew),
    'newold' => serialize($newOld),
  );
  variable_set($var1, serialize($saveArr));
  variable_set($var2, serialize($saveArr));
}

function _get_nodemaps($mode='step1') {

/*
 * Consultants Firms, Office & Manager Firms, Plans & Mandates
 */
$nm_co = array(
    'office' => array(
      'params' => array(
        'oldtable' => 'tblconsultantoffices',
        'oldkeyfldname' => 'ConsultantOfficeID',
        'dst' => 'office',
      ),
      'system' => array(
        'fields' => array(
          'node-title' => array(
            'title' => array('fldname'=>'ConsultantOfficeName'), 
          ),
          'node-body' => array(
            'body' => array('fldname'=>'Comments'),      
          ),
        ),
      ),
      'fields' => array(
        'default' => array(
          'title_field' => array('fldname'=>'ConsultantOfficeName'),
        ),
        'lu2term' => array(
          'field_office_type_tr' => array('fldname'=>'OfficeType'),
        ),
        'text2email' => array(
          'field_email' => array('fldname'=>'Email'),
        ),
        'reference' => array(
          'field_consultant_firm_er'=>array('fldname'=>'ConsultantFirmID'),
        ),
        'address' => array(
          'field_address' => array(
            'fields' => array(
              'default' => array(
                'thoroughfare' => array('fldname'=>array('Address1')),
                'premise' => array('fldname'=>array('Address2')),
                'address3' => array('fldname'=>array('Address3')),
                'locality' => array('fldname'=>'City'),
                'postal_code' => array('fldname'=>'ZIP'),
              ),
              'phone' => array(
                'phone_number' => array('fldname'=>'Phone'),
                'fax_number' => array('fldname'=>'Fax'),
              ),
              'lu2state' => array(
                'administrative_area' => array('fldname'=>'StateID'),
              ),
              'lu2country' => array(
                'country' => array('fldname'=>'CountryID'),
              ),
            ),
          ),
        ),
      ),
    ),
  );

  $nm_cf = array(
    'consultant firm' => array(
      'params' => array(
        'oldtable' => 'tblconsultantfirms',
        'oldkeyfldname' => 'ConsultantFirmID',
        'dst'=>'consultant_firm',
      ),
      'system' => array(
        'fields' => array(
          'node-title' => array(
            'title' => array('fldname'=>'ConsultantFirmName'),
          ),
          'node-body' => array(
            'body' => array('fldname'=>'Comments'),      
          ),
        ),
      ),
      'fields' => array(
        'default' => array(
          'title_field' => array('fldname'=>'ConsultantFirmName'),
          'field_aua' => array('fldname'=>'AUA'),
        ),
        'text2email' => array(
          'field_email' => array('fldname'=>'Email'),
        ),
        'http2link' => array(
          'field_website' => array('fldname'=>'Website'),          
        ),
        'inactive2term' => array(
          'field_status_tr' => array('fldname'=>'Inactive'),
        ),
      ),
    ),
  );

  $nm_mf = array(
    'manager firm' => array(
      'params' => array(
        'oldtable' => 'tblmanagerfirms',
        'oldkeyfldname' => 'ManagerFirmID',
        'dst'=>'manager_firm',
      ),
      'system' => array(
        'fields' => array(
          'node-title' => array(
            'title' => array('fldname'=>'ManagerFirmName'),
          ),
          'node-inactive-status' => array(
            'status' => array('fldname'=>'Archive'),
          ),
        ),
      ),
      'fields' => array(
        'default' => array(
          'title_field' => array('fldname'=>'ManagerFirmName'),
        ),
        'mom' => array(
          'field_sub_manager_firms_er' => array(
            'oldtable' => 'tblmommanagers',
            'fldname' => 'ManagerFirmID',
            'primeKeyfldname' => 'MoMID',
          ),
        ),
        'text2email' => array(
          'field_email' => array('fldname'=>'Email'),
        ),
        'http2link' => array(
          'field_website' => array('fldname'=>'Website'),          
        ),
        'value2term' => array(
          'field_status_tr' => array('fldname'=>'Archive', 'handler'=>'negate', 'voc'=>5, 'values'=>array('0'=>'Inactive','1'=>'Active')),
        ),
        'address' => array(
          'field_address' => array(
            'fields' => array(
              'default' => array(
                'thoroughfare' => array('fldname'=>array('Address1')),
                'premise' => array('fldname'=>array('Address2')),
                'locality' => array('fldname'=>'City'),
                'postal_code' => array('fldname'=>'Zip'),
              ),
              'phone' => array(
                'phone_number' => array('fldname'=>'Phone'),
                'fax_number' => array('fldname'=>'Fax'),
              ),
              'lu2state' => array(
                'administrative_area' => array('fldname'=>'StateID'),
              ),
              'lu2country' => array(
                'country' => array('fldname'=>'CountryID'),
              ),
            ),
          ),
        ),
      ),
    ),
  );
    
  $nm_p = array(
    'plan' => array(
      'params' => array(
        'oldtable' => 'tblfunds',
        'oldkeyfldname' => 'FundID',
        'dst' => 'plan',
      ),
      'system' => array(
        'fields' => array(
          'node-title' => array(
            'title' => array('fldname'=>'FundName'),
          ),
          'node-body' => array(
            'body' => array(),      
          ),
        ),
      ),
      'fields' => array(
        'default' => array(
          'title_field' => array('fldname'=>'FundName'),
          'field_plan_acronym' => array('fldname'=>'Acronym'),
        ),
        'http2link' => array(
          'field_website' => array('fldname'=>'Website'),
          'field_placement_policy_link' => array('fldname'=>'PlacementPolicyLink', 'title'=>'Placement Policy'),
        ),
        'lu2term' => array(
          'field_placement_policy_tr' => array('fldname'=>'PlacementPolicy'),
          'field_plan_type_tr' => array('fldname'=>'FundTypeID'),
          'field_currency_tr' => array('fldname'=>'CurrencyID'),
          'field_status_tr' => array('fldname'=>'Status', 'voc'=>'5'),
        ),          
        'text2email' => array(
           'field_email' => array('fldname'=>'Email'),
        ),
        'http2link' => array(
          'field_website' => array('fldname'=>'Website'),          
        ),
        'address' => array(
          'field_address' => array(
            'fields' => array(
              'default' => array(
                'thoroughfare' => array('fldname'=>array('Address1')),
                'premise' => array('fldname'=>array('Address2')),
                'address3' => array('fldname'=>array('Address3')),
                'locality' => array('fldname'=>'City'),
                'postal_code' => array('fldname'=>'Zip'),
              ),
              'phone' => array(
                'phone_number' => array('fldname'=>'Phone'),
                'fax_number' => array('fldname'=>'Fax'),
              ),
              'lu2state' => array(
                'administrative_area' => array('fldname'=>'StateID'),
              ),
              'lu2country' => array(
                'country' => array('fldname'=>'CountryID'),
              ),
            ),
          ),
        ),
        'collection' => array(
          'field_asset_allocation_history' => array(
            'params' => array(
            ),
            'sets' => array(
              array(
                'params' => array(
                  'oldtable' => 'finsearch_asset_allocations',
                  'rowkeyfldname' => 'allocation_id',                  
                  'key-alias' => 'firm_id',
                  'onerow' => 'TRUE',
                  'onerowkeyname' => 'asset_class_id',
                  'onerowfldname' => 'percentage',
                ),
                'fields' => array(
                  'asset-allocation' => array(
                    'automatically-determined' => array('fldname'=>'percentage', 'keyfldname'=>'asset_class_id'),
                  ),
                ),
              ),
            ),              
          ),
          'field_consultants_hired' => array(
            'sets' => array(
              array(
                'params' => array(
                  'oldtable' => 'tblfundconsultants',
                  'rowkeyfldname' => 'FundConsultantID',
                ),
                'fields' => array(
                  'reference' => array(
                    'field_consultant_firm_er' => array('fldname'=>'ConsultantFirmID'),
                    'field_consultant_contact_er' => array('fldname'=>'ConsultantContactID'),
                  ),
                ),
              ),
            ),              
          ),
          'field_managers_hired' => array(
            'sets' => array(
              array(
                'params' => array(
                  'oldtable' => 'tblfundmanagers',
                  'rowkeyfldname' => 'FundManagerID',
                ),
                'fields' => array(
                  'default' => array(
                    'field_amount' => array('fldname'=>'Amount'),                  
                  ),
                  'lu2term' => array(
                    'field_geographic_tr' => array('fldname'=>'GeographicID'),
                  ),
                  'reference' => array(
                    'field_manager_firm_er' => array('fldname'=>'ManagerFirmID'),
                  ),
                ),
              ),
            ),              
          ),
          'field_plan_size_history' => array(
            'params' => array(
            ),
            'sets' => array(
              array(
                'params' => array(
                  'rowkeyfldname' => 'FundID',
                ),
                'fields' => array(
                  'default' => array(
                    'field_plan_size' => array('fldname'=>'FundSize'),
                  ),
                  'date2timestamp' => array(
                    'field_date' => array('fldname'=>'FundSizeAsOfDate'),
                  ),
                ),
              ),
            ),              
          ),
          'field_foia_history' => array(
            'sets' => array(
              array(
                'params' => array(
                  'rowkeyfldname' => 'FundID',
                ),
                'fields' => array(
                  'mixed2link' => array(
                    'field_foia_form' => array('fldname'=>'FOIAForm')
                  ),
                  'foia2notes' => array(
                    'field_foia_notes' => array('names'=>array('FOIAMethod', 'FOIAForm'))
                  ),
                  'default' => array(
                    'field_full_name' => array('fldname'=>'FOIAContactName'),
                    'field_foia_required' => array('fldname'=>'FOIA'),
                    'field_foia_date' => array('fldname'=>'FOIADate'),                  
                  ),
                ),
              ),
            ),              
          ),
        ),
      ),
    ),
  );

  $nm_m = array(
    'mandate' => array(
      'params' => array(
        'oldtable' => 'tblmandates',
        'oldkeyfldname' => 'MandateID',
        'dst' => 'mandate',
      ),
      'system' => array(
        'fields' => array(
          'node-body' => array(
            'body' => array('fldname'=>'History'),      
          ),
          'node-inactive-status' => array(
            'status' => array('fldname'=>'Archive'),
          ),
        ),
      ),
      'fields' => array(
        'default' => array(
          'field_title' => array('fldname'=>'FundName'),
          'field_account_size' => array('fldname'=>'Size'),
          'field_plan_size' => array('fldname'=>'FundSize'),
        ),
        'date2date' => array(
          'field_date' => array('fldname'=>'MandateDate'),
          'field_rfp_date' => array('fldname'=>'RFPDate'),
        ),
        'http2link' => array(
          'field_placement_policy_link' => array('fldname'=>'PlacementPolicyLink'),
          'field_rfp_link' => array('fldname'=>'RFPLink'),
          'field_website' => array('fldname'=>'Website'),
        ),
        'lu2term' => array(
          'field_mandate_status_tr' => array('fldname'=>'StatusID'),
          'field_geographic_tr' => array('fldname'=>'GeographicID'),
          'field_attribute_tr' => array(),
          'field_currency_tr' => array('fldname'=>'CurrencyID'),
        ),
        'summed' => array(
          'field_managed_amount' => array('fldname'=>'FirmsHiredAmount'),
        ),
        'majorminor' => array(
          'field_major_minor_style_tr' => array('fields'=>array('major'=>'MajorStyleID', 'minor'=>'MinorStyleID')),
        ), 
        'reference' => array(
          'field_plan_er' => array('fldname'=>'FundID'),
          'field_consultant_firm_er' => array('fldname'=>'ConsultantFirmID'),
          'field_manager_firm_er' => array('fldname'=>'ManagerFirmID'),
        ),
        'onwatch' => array(
          'field_consultants_finalists_er' => array('fldname'=>'ConsultantFinalists', 'oldkeyfldname'=>'ConsultantFirmID'),
          'field_consultants_terminated_er' => array('fldname'=>'ConsultantFirmsTerminated', 'oldkeyfldname'=>'ConsultantFirmID'),
          'field_managers_onwatch_er' => array('fldname'=>'FirmsOnWatch', 'oldkeyfldname'=>'ManagerFirmID'),
          'field_managers_finalists_er' => array('fldname'=>'Finalists', 'oldkeyfldname'=>'ManagerFirmID'),
          'field_managers_terminated_er' => array('fldname'=>'FirmsTerminated'),
        ),
        'collection' => array(
          'field_consultants_hired' => array(
            'sets' => array(
              array(
                'params' => array(
                  'oldtable' => 'tblmandates',
                  'rowkeyfldname' => 'MandateID',
                ),
                'fields' => array(
                  'multiplier' => array(
                    'field_consultant_firm_er' => array('fldname'=>'ConsultantFirmsHired', 'handler'=>'comma-delimited-er'),
                  ),
                ),
              ),
            ),              
          ),
          'field_managers_hired' => array(
            'sets' => array(
              array(
                'params' => array(
                  'oldtable' => 'tblfundmanagers',
                  'rowkeyfldname' => 'FundManagerID',
                ),
                'fields' => array(
                  'multiplier' => array(
                    'field_consultant_firm_er' => array('fldname'=>'ConsultantFirmsHired', 'handler'=>'comma-delimited-er'),
                  ),
                  'default' => array(
                    'field_amount' => array('fldname'=>'Amount'),                  
                  ),
                  'lu2term' => array(
                    'field_geographic_tr' => array('fldname'=>'GeographicID'),
                  ),
                  'reference' => array(
                    'field_manager_firm_er' => array('fldname'=>'ManagerFirmID'),
                  ),
                ),
              ),
            ),              
          ),
          'field_mandate_notes' => array(
            'sets' => array(
              array(
                'fields' => array(
                  'note-comment-to-note' => array(),
                  'note-history-to-note' => array(),
                ),
              ),
              array(
                'oldtable' => 'tblmandatecomments',
                'fields' => array(
                  'note-comments-to-note' => array(),
                ),
              ),
            ),
          ),
        ),
      ),
    ),
  );
// 242 Matt | 260 Gar SourceID just make UID 1
// gar guymoso@Yahoo.com matt matt mmccue@fin-news.com

/*
 * Contacts - nm_cc, nm_mc, nm_pc used in step 1, nm_contact used in step 2
 */
  $nm_contact = array(
    'contact' => array(
      'params' => array(
        'dst'=>'contact',
      ),
      'system' => array(
        'fields' => array(
          'node-title' => array(
            'title' => array('fldname'=>'ContactName'),
          ),
          'node-body' => array(
            'body' => array('fldname'=>'Bio'),      
          ),
          'default' => array(
            'title_field' => array('fldname'=>'ContactName'),
          ),
          'picture' => array(
            'field_photo' => array('fldname'=>'Picture'),
          ),
        ),
      ),
      'job-history' => array(
        'params' => array(
          'hostfield' => 'field_job_history',
        ),
        'bundles' => array(
          'tblconsultantcontacts' => array(
            'params' => array(
              'bundle'=>'consultant_contact',
            ),
            'fields' => array(
              'default'=>array(
                'field_job_title'=>array('fldname'=>'Title'),
              ),
              'lu2term' => array(
                'field_consultant_type_tr' => array('fldname'=>'ConsultantType'),
              ),
              'term2term' => array(
                'field_job_type_tr' => array('value'=>'consultant contact'),
              ),
              'employmentdate' => array(
                'field_employment_date' => array(
                  'fldname' => 'start',
                  'date2' => 'end',
                ),
              ),
              'inactive2term' => array(
                'field_status_tr' => array('fldname'=>'Inactive'),
              ),
              'text2email' => array(
                'field_email' => array('fldname'=>'Email'),
              ),
              'reference' => array(
                'field_consultant_firm_er' => array('fldname'=>'er'),
                'field_consultant_office_er' => array('fldname'=>'ConsultantOfficeID'),
              ),
              'address' => array(
                'field_address' => array(
                  'fields' => array(
                    'default' => array(
                      'thoroughfare' => array('fldname'=>array('Address')),
                      'locality' => array('fldname'=>'City'),
                      'postal_code' => array('fldname'=>'ZIP'),
                    ),
                    'phone' => array(
                      'phone_number' => array('fldname'=>'Phone'),
                      'fax_number' => array('fldname'=>'Fax'),
                    ),
                    'lu2state' => array(
                      'administrative_area' => array('fldname'=>'StateID'),
                    ),
                    'lu2country' => array(
                      'country' => array('fldname'=>'CountryID'),
                    ),
                  ),
                ),
              ),       
            ),
          ),
          'tblmanagercontacts' => array(
            'params' => array(
              'bundle'=>'manager_contact',
            ),
            'fields' => array(
              'default' => array(
                'field_job_title' => array('fldname'=>'Title'),
              ),
              'employmentdate' => array(
                'field_employment_date' => array(
                  'fldname' => 'start',
                  'date2' => 'end',
                ),
              ),
              'term2term' => array(
                'field_job_type_tr' => array('value'=>'manager contact'),
              ),
              'lu2term' => array(
                'field_consultant_type_tr' => array('fldname'=>'ConsultantType'),
              ),
              'inactive2term' => array(
                'field_status_tr' => array('fldname'=>'Inactive'),
              ),
              'text2email' => array(
                'field_email' => array('fldname'=>'Email'),
              ),
              'reference' => array(
                'field_manager_firm_er' => array('fldname'=>'er'),
              ),
              'address' => array(
                'field_address' => array(
                  'fields' => array(
                    'default' => array(
                      'thoroughfare' => array('fldname'=>array('Address')),
                      'locality' => array('fldname'=>'City'),
                      'postal_code' => array('fldname'=>'ZIP'),
                    ),
                    'phone' => array(
                      'phone_number' => array('fldname'=>'Phone'),
                      'fax_number' => array('fldname'=>'Fax'),
                    ),
                    'lu2state' => array(
                      'administrative_area' => array('fldname'=>'StateID'),
                    ),
                    'lu2country' => array(
                      'country' => array('fldname'=>'CountryID'),
                    ),
                  ),
                ),
              ),
            ),
          ),       
          'tblfundcontacts' => array(
           'params'=> array(
             'bundle' => 'plan_contact',
            ),
            'fields' => array(
              'default' => array(
                'title_field' => array('fldname'=>'Title'),
                'field_job_title' => array('fldname'=>'Title'),
              ),
              'employmentdate' => array(
                'field_employment_date' => array(
                  'fldname' => 'start',
                  'date2' => 'end',
                ),
              ),
              'inactive2term' => array(
                'field_status_tr' => array('fldname'=>'Inactive'),
              ),
              'term2term' => array(
                'field_job_type_tr' => array('value'=>'plan contact'),
              ),
              'text2email' => array(
                'field_email' => array('fldname'=>'Email'),
              ),
              'reference' => array(
                'field_plan_er' => array('fldname'=>'er'),
              ),       
              'address' => array(
                'field_address' => array(
                  'params' => array(
                    'oldtable' => 'tblManagerFirms',
                    'oldkeyfldname' => 'ManagerFirmID',
                  ),
                  'fields' => array(
                    'default' => array(
                      'thoroughfare' => array('fldname'=>array('Address')),
                      'locality' => array('fldname'=>'City'),
                      'postal_code' => array('fldname'=>'ZIP'),
                    ),
                    'phone' => array(
                      'phone_number' => array('fldname'=>'Phone'),
                      'fax_number' => array('fldname'=>'Fax'),
                    ),
                    'lu2state' => array(
                      'administrative_area' => array('fldname'=>'StateID'),
                    ),
                    'lu2country' => array(
                      'country' => array('fldname'=>'CountryID'),
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
      ),     
    ),
  );

// fundcontact Inactive,   
  $nm_cc = array(
    'consultant contact' => array(
      'params' => array(
        'oldtable' => 'tblconsultantcontacts',
        'oldkeyfldname' => 'ConsultantContactID',
        'dst'=>'contact',
        'checkname' => array('fldname'=>'ContactName'),
      ),
      'system' => array(
        'fields' => array(
          'node-title' => array(
            'title' => array('fldname'=>'ContactName'),
            'node-body' => array(
              'body' => array('fldname'=>'Bio'),
            ),
          ),
        ),
      ),
    ),
  );

  $nm_mc = array(
    'consultant contact' => array(
      'params' => array(
        'oldtable' => 'tblmanagercontacts',
        'oldkeyfldname' => 'ManagerContactID',
        'dst'=>'contact',
        'checkname' => array('fldname'=>'ContactName'),
      ),
      'system' => array(
        'fields' => array(
          'node-title' => array(
            'title' => array('fldname'=>'ContactName'),
            'node-body' => array(
              'body' => array('fldname'=>'Bio'),
            ),
          ),
        ),
      ),
    ),
  );

  $nm_pc = array(
    'fund contact' => array(
      'params' => array(
        'oldtable' => 'tblfundcontacts',
        'oldkeyfldname' => 'FundContactID',
        'dst'=>'contact',
        'checkname' => array('fldname'=>'ContactName'),      
      ),
      'system' => array(
        'fields' => array(
          'node-title' => array(
            'title' => array('fldname'=>'ContactName'),
            'node-body' => array(
              'body' => array('fldname'=>'Bio'),
            ),
          ),
        ),
      ),
    ),
  );

  $nodeMapArr = FALSE;
  if ($mode=="step1") {
    $nodeMapArr = array(
      $nm_p, 
      $nm_cc,
      $nm_mc,
      $nm_cf,
      $nm_co,
      $nm_mf,
      $nm_pc, 
      $nm_m  
    );
  }
  else if ($mode=="step2") {
    $nodeMapArr = array(
      $nm_mf,
      $nm_cf,
      $nm_contact,
      $nm_cf,
      $nm_co,
      $nm_p, 
      $nm_m, 
    );
  }
  return $nodeMapArr;
// END BIG NODE MAP ARRAY

}
